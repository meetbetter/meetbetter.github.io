---
title: "go slice"
date: 2018-08-30T23:03:59+08:00
description: ""
draft: false
tags: [Golang]
categories: [study]
---
# 文章说明
总结了go语言中切片slice的特殊性和使用时的注意事项。

个人理解，不足之处欢迎指出。

slice：切片，是go语言中一种常用的数据结构，基于数组构建，表示相同数据类型的集合。
# 数组
Go中数组类型表示固定长度的相同类型的数据的集合，数据在内存中连续存储，可以通过下标索引，但是又有特殊的地方：
- 数组是值类型，一个数组变量表示整个数组，而不是指向数组的首元素的指针，这和C语言不同。
- 将数组赋值给另一个数组，或者数组作函数参数传递时，会将数组的全部数据拷贝一份过去而不是传递一个指针。
- 数组类型包括长度，即[5]int和[10]不是一种类型。

所以Go语言中使用数组传递数据效率很低，通常使用切片。
# 切片
切片是一个数组片段的描述，包含了指向数组片段的指针，片段的长度len和容量cap（数组片段的最大长度），但是**切片本身并不是真正的指针类型**。
## 切片的特性
1. 可以自动扩容
使用append()向切片**追加**数据，数据是被添加到切片指向的片段末尾，长度等于容量时切片就会自动扩容，扩容的细节后面的文章再讨论。
2. 切片之间赋值或者切片作函数参数传递时，是将指向数组片段的指针传递过去，所以改变一个会影响另一个。

## 切片的陷阱
切片作函数参数传递或浅拷贝时，之所以改变一个切片的数据会影响另一个切片，是因为两个切片中中包含了指向同一数组片段的指针。

一切看似正常？但是当一个切片发生扩容时，会将当前切片内的数据复制到另一片内存区域，该切片的数组片段的地址发生改变，所以当切片扩容时修改一个切片的数据时不会再影响到另一个切片！此时只能通过传递切片本身的地址来解决。

扩容时出错的代码如下：
```
package main

import "fmt"

func testSlice(slice []int) {
slice = append(slice, 6, 7, 8, 9, 10)
fmt.Println("testSlice:",slice)
}
func main() {
slice := []int{1, 2, 3, 4, 5}

	testSlice(slice)
fmt.Println("main:",slice)
}
```
# 切片的本质
可以证明，**切片不是指针类型，切片数据类型是包含指向一个数组片段的指针，和当前数组片段的长度，以及当前数组最大容量的一种复合数据结构**。

想深入了解Go中slice数据类型的底层实现，可以参考本人的Github[自己动手实现Go切片数据结构](https://github.com/meetbetter/go-programming)