<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://meetbetter.github.io</id>
    <title>Betterman</title>
    <updated>2019-08-17T12:25:52.440Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://meetbetter.github.io"/>
    <link rel="self" href="https://meetbetter.github.io/atom.xml"/>
    <subtitle>记录自己，期望可以帮到需要的人</subtitle>
    <logo>https://meetbetter.github.io/images/avatar.png</logo>
    <icon>https://meetbetter.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Betterman</rights>
    <entry>
        <title type="html"><![CDATA[架构之路]]></title>
        <id>https://meetbetter.github.io/post/to-be-architect</id>
        <link href="https://meetbetter.github.io/post/to-be-architect">
        </link>
        <updated>2019-05-16T09:59:12.000Z</updated>
        <content type="html"><![CDATA[<p>当你的收入跟不上你的梦想，说明你的能力匹配不上你的梦想。<br>
<img src="https://i.loli.net/2019/08/16/sLT4rRQUelcVx3d.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang map底层实现]]></title>
        <id>https://meetbetter.github.io/post/go-map</id>
        <link href="https://meetbetter.github.io/post/go-map">
        </link>
        <updated>2019-03-26T13:46:28.000Z</updated>
        <content type="html"><![CDATA[<p>首先否定两个错误说法：“map高效率是因为map是链式结构存储”，“map的无序是因为map是散列表”。这是之前听到的说法，后来深入学习了golang map的底层实现后，发现这些说法是很错误的，现在将自己学习map的心得整理出来，欢迎指正。</p>
<h1 id="map的底层实现">map的底层实现</h1>
<p>粗略的讲，Go语言中map采用的是哈希查找表，由一个key通过哈希函数得到哈希值，64位系统中就生成一个64bit的哈希值，由这个哈希值将key对应到不同的桶（bucket）中，当有多个哈希映射到相同的的桶中时，使用链表解决哈希冲突。<br>
详细的说，就涉及到map的数据结构哈希函数，hmap，bmap。</p>
<h2 id="hash函数">hash函数</h2>
<p>首先要知道的就是map中哈希函数的作用，go中map使用hash作查找，就是将key作哈希运算，得到一个哈希值，根据哈希值确定key-value落在哪个bucket的哪个cell。golang使用的hash算法和CPU有关，如果cpu支持aes，那么使用aes hash，否则使用memhash。</p>
<h2 id="map的数据结构">map的数据结构</h2>
<h3 id="hmap">hmap</h3>
<p>hmap可以理解为 header of map的缩写，即map数据结构的入口。<br>
map的数据结构定义在<code>runtime/map.go/hmap</code>中，以下注释来自<a href="https://github.com/cch123/golang-notes/blob/master/map.md">曹大Github map源码分析</a>，我修改了部分注释使之更直白：</p>
<pre><code class="language-go">// header of map
type hmap struct {
    count     int // map 中的元素个数，必须放在 struct 的第一个位置，因为 内置的 len 函数会从这里读取
    flags     uint8 //map状态标识，比如是否在被写或者迁移等，因为map不是线程安全的所以操作时需要判断flags
    B         uint8  // log_2 of # of buckets (最多可以放 loadFactor * 2^B 个元素即6.5*2^B，再多就要 hashGrow 了)
    noverflow uint16 // overflow 的 bucket 的近似数
    hash0     uint32 // hash seed，随机哈希种子可以防止哈希碰撞攻击

    buckets    unsafe.Pointer // 存储数据的buckets数组的指针， 大小2^B，如果 count == 0 的话，可能是 nil
    oldbuckets unsafe.Pointer // 一半大小的之前的 bucket 数组，只有在 growing 过程中是非 nil
    nevacuate  uintptr        // 扩容进度标志，小于此地址的buckets已迁移完成。

    extra *mapextra // 可以减少GC扫描，当 key 和 value 都可以 inline 的时候，就会用这个字段
}
</code></pre>
<p>根据注释可以看出各个字段的作用，需要重点说明的是最后一个字段<code>extra *mapextra</code>，针对key和value都不是指针类型的map，并且大小都小于128字节，则使用mapextra来存储，这样可以避免GC扫描整个map。</p>
<pre><code class="language-go">type mapextra struct {
    // 如果 key 和 value 都不包含指针，并且可以被 inline(&lt;=128 字节)
    // 使用 extra 来存储 overflow bucket，这样可以避免 GC 扫描整个 map
    // 然而 bmap.overflow 也是个指针。这时候我们只能把这些 overflow 的指针
    // 都放在 hmap.extra.overflow 和 hmap.extra.oldoverflow 中了
    // overflow 包含的是 hmap.buckets 的 overflow 的 bucket
    // oldoverflow 包含扩容时的 hmap.oldbuckets 的 overflow 的 bucket
    overflow    *[]*bmap
    oldoverflow *[]*bmap

    // 指向空闲的 overflow bucket 的指针
    nextOverflow *bmap
}
</code></pre>
<h3 id="bmap">bmap</h3>
<p>bmap可以理解为buckets of map的缩写，她就是map中bucket的本体，即存key和value数据的“桶”。</p>
<pre><code class="language-go">type bmap struct {
    // tophash 是 hash 值的高 8 位
    tophash [bucketCnt]uint8
		//以下字段没有显示定义在bmap，但是编译时编译器会自动添加
    // keys //每个桶最多可以装8个key
    // values //8个key分别有8个value一一对应
    // overflow pointer  //发生哈希碰撞之后创建的overflow bucket
}
</code></pre>
<p>根据哈希函数将key生成一个哈希值，其中低位哈希用来判断桶位置，高位哈希用来确定在桶中哪个cell。<strong>低位哈希</strong>就是哈希值的低B位，hmap结构体中的B，比如B为5，2^5=32，即该map有32个桶，只需要取哈希值的低5位就可以确定当前key-value落在哪个桶(bucket)中；<strong>高位哈希</strong>即tophash，是指哈希值的高8bits，根据tophash来确定key在桶中的位置。每个桶可以存储8对key-value，存储结构不是key/value/key/value...，而是key/key..value/value，这样可以避免字节对时的padding，节省内存空间。</p>
<p>仔细想一下，当不同的key根据哈希得到的tophash和低位hash都一样岂不是会覆盖原来的key-value数据？这种情况有个专业名词叫“哈希碰撞”，这个时候就体现<code>overflow pointer</code>字段的作用了。当某一个key根据自己的哈希值找到对应的bucket和key位置时，发现这个位置已经名花有主，即桶溢出了，就需要存储在overflow bucket（溢出桶），overflow pointer就是指向overflow bucket的指针。如果overflow bucket也溢出了呢？那就再给overflow bucket新建一个overflow bucket，用指针串起来就形成了链式结构，所以开头所说的“map是链式存储并不准确”，map本身有2^B个bucket，只有当发生哈希碰撞后才会在bucket后链式增加overflow bucket。</p>
<h2 id="map内存布局">map内存布局</h2>
<p>通过上面我们可以想象map在内存中的布局情况：<br>
一个map对应着多个buckets，每个bucket后面又因为哈希碰撞而存在数量不定的overflow bucket。<br>
<img src="https://meetbetter.github.io/post-images/1564210141673.png" alt=""></p>
<h2 id="扩容">扩容</h2>
<p>再仔细想一下，如果overflow bucket一直链式增加，但是并不是每个bucket的8个cell都是满的，那map的高效率还能保证吗？<br>
这就需要用到map的扩容机制了，当向map插入数据时，会判断是否满足以下两个条件之一：</p>
<ol>
<li>装载因子是否大于6.5</li>
</ol>
<blockquote>
<p>装载因子 = 元素个数/桶个数，大于6.5时说明大部分桶已经要装满，需要扩容。</p>
</blockquote>
<ol start="2">
<li>overflow bucket是否太多。</li>
</ol>
<blockquote>
<p>当 bucket数量 &lt; 2^15时，如果overflow bucket数量大于bucket数量，则说明overflow bucket数量太多了；<br>
当bucket数量 &gt;= 2^15时，如果overflow bucket数量大于2^15，则说明overflow bucket数量太多了；<br>
overflow bucket桶太多说明有很多cell空闲，查找效率就会变低。曹大文章里说导致这种情况的原因是map一遍插入一边删除，但map不是线程安全的，一遍插入一边删除会导致panic，所以我的理解不是同时插入，而是先往map中插入了大量哈希值高低位相同的key，导致overflow bucket数量很多，再删除一些数据，这时装载因子并未大于6.5，但却有大量的overflow bucket，这就造成很多bucke的cell空着，却有大量的overflow bucket，从而降低查询效率。</p>
</blockquote>
<p>两种触发条件的适用的场景不一致，扩容方法也不一致。针对第一种装载因子过大的情况，只需要bucket数量增加一倍，即B+1，这称为“双倍扩容”。针对第二种overflow太多的情况，使用的方法是重新排列键值对使之排列更紧密，减少overflow bucket，bucket总数未改变，这称为“等量扩容”。</p>
<blockquote>
<p>但是在极端情况下，比如插入了大量的哈希值高低位相同的key，第二种方法也无能为力，为了解决哈希碰撞不得不使用overflow bucket，此时map变成了链式存储，查询和插入效率就会变低，hmap中的hash0字段是makemap时的rand seed，可以降低这种极端情况的发生 。</p>
</blockquote>
<p>在第一种情况下，B+1之后，根据key的哈希值低B位查找落在哪个桶也需要加一，即向前多取一位哈希值来当作新的低哈希，所以数据搬移后原来的key可能落在其他桶中，取决于向前取的这一位是0还是1。<br>
另外，map的扩容是渐进式的扩容，并不是一次性将原bucket的数据搬移到新的地址，这样未免太占用CPU了，而是在每一次访问旧buckets时就搬移一部分，直到全部搬移完成，旧的buckets被GC回收。</p>
<h2 id="查找过程">查找过程</h2>
<p>通过上面的介绍可以直到map的查找过程：</p>
<ol>
<li>根据key计算出哈希值</li>
<li>根据哈希值低位确定所在bucket</li>
<li>根据哈希值高8位确定在bucket中的存储位置</li>
<li>当前bucket未找到则查找对应的overflow bucket。</li>
<li>对应位置有数据则对比完整的哈希值，确定是否是要查找的数据</li>
<li>如果当前处于map进行了扩容，处于数据搬移状态，则优先从oldbuckets查找。</li>
</ol>
<p>先用哈希值高低位确定位置再对比完整哈希值的方法提高了查找效率。<br>
另外要注意：查找不到也不会返回空值，而是返回对应数据类型的零值，所以我们判断map中某个key是否存在时要接收两个返回值，如 <code>data,ok := m[&quot;hahaha&quot;]</code>，第二个返回值为bool类型，标识查询的数据是否存在。</p>
<h2 id="插入过程">插入过程</h2>
<p>删除map数据的过程是先查找再删除：</p>
<ol>
<li>根据key计算出哈希值</li>
<li>根据哈希值低位确定所在bucket</li>
<li>根据哈希值高8位确定在bucket中的存储位置</li>
<li>查找该key是否存在，已存在则更新，不存在则插入</li>
</ol>
<h1 id="map无序的原因">map无序的原因</h1>
<p>看完上面的内容，可以理解“map高效率是因为map是链式结构存储”是错误的说法了吧，那为什么“map的无序是因为map是散列表”也是错误的呢？之前在网上看到说因为map是哈希的，所以遍历出来是无序的。其实map无序和哈希无关，而是<strong>Go map遍历出的结果是随机的是因为Go设计者故意这样做的</strong>。<br>
分析如下：<br>
通过上面的学习已经知道，map的本质是散列表，而map的增长扩容会导致重新进行散列，这就可能使map的遍历结果在扩容前后变得不可靠，Go设计者为了让大家不依赖遍历的顺序，故意在实现map遍历时加入了随机数，让每次遍历的起点--即起始bucket的位置--不一样，即不让遍历都从bucket0开始，所以即使未扩容时我们遍历出来的map也总是无序的(<em><sup>_</sup></em>)。<br>
看一下runtime.mapiterinit源码：</p>
<pre><code class="language-go">func mapiterinit(t *maptype, h *hmap, it *hiter) {
    ...
    it.t = t
    it.h = h
    it.B = h.B
    it.buckets = h.buckets
    if t.bucket.kind&amp;kindNoPointers != 0 {
        h.createOverflow()
        it.overflow = h.extra.overflow
        it.oldoverflow = h.extra.oldoverflow
    }

    r := uintptr(fastrand())
    if h.B &gt; 31-bucketCntBits {
        r += uintptr(fastrand()) &lt;&lt; 31
    }
    it.startBucket = r &amp; bucketMask(h.B)
    it.offset = uint8(r &gt;&gt; h.B &amp; (bucketCnt - 1))
    it.bucket = it.startBucket
    ...

    mapiternext(it)
}
</code></pre>
<p>这个函数是map遍历前的初始化操作，注意看<code>fastrand())</code>，根据名字也可以猜出它的作用了吧，就是<code>fastrand())</code>生成随机数让每次遍历的起始位置不停变化。<br>
个人猜测不同CPU下哈希函数的选择可能不同也是促使go设计者这样做的原因之一。</p>
<h2 id="让map变有序的方法">让map变有序的方法</h2>
<p>如果想让map遍历结果变得有序，可以自己对map的key进行依次排序，实现如下：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	m := make(map[string]string)
	m[&quot;111&quot;] = &quot;1111&quot;
	m[&quot;222&quot;] = &quot;2222&quot;
	m[&quot;333&quot;] = &quot;3333&quot;
	m[&quot;444&quot;] = &quot;4444&quot;
	m[&quot;555&quot;] = &quot;5555&quot;

	sorted_keys := make([]string, 0)
	for k, _ := range m {
		sorted_keys = append(sorted_keys, k)
	}

	// sort 'string' key in increasing order
	sort.Strings(sorted_keys)

	for _, k := range sorted_keys {
		fmt.Printf(&quot;k=%v, v=%v\n&quot;, k, m[k])
	}
}
</code></pre>
<p>至此相信你对Golang map的底层实现有个大概认知了吧，最后再说一句，go中只有值传递，map和channel可以在函数内影响函数外是因为他们make创建时就是返回的对应指针：</p>
<pre><code class="language-go">func makemap(t *maptype, hint int, h *hmap) *hmap {
    // 在 64 位系统上 hmap 结构体大小为 48 字节
    // 32 位系统上是 28 字节
    if sz := unsafe.Sizeof(hmap{}); sz != 8+5*sys.PtrSize {
        println(&quot;runtime: sizeof(hmap) =&quot;, sz, &quot;, t.hmap.size =&quot;, t.hmap.size)
        throw(&quot;bad hmap size&quot;)
    }

    if hint &lt; 0 || hint &gt; int(maxSliceCap(t.bucket.size)) {
        hint = 0
    }

    // 初始化 hmap
    if h == nil {
        h = (*hmap)(newobject(t.hmap))
    }
    h.hash0 = fastrand()

    // 按照提供的元素个数，找一个可以放得下这么多元素的 B 值
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // 分配初始的 hash table
    // 如果 B == 0，buckets 字段会由 mapassign 来 lazily 分配
    // 因为如果 hint 很大的话，对这部分内存归零会花比较长时间
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B)
        if nextOverflow != nil {
            h.extra = new(mapextra)
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
</code></pre>
<p>参考资料：<br>
<a href="https://github.com/cch123/golang-notes/blob/master/map.md">曹大map源码分析</a><br>
<a href="https://www.jianshu.com/p/aa0d4808cbb8">Golang map 的底层实现</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang并发控制之道]]></title>
        <id>https://meetbetter.github.io/post/golang-concurrent</id>
        <link href="https://meetbetter.github.io/post/golang-concurrent">
        </link>
        <updated>2019-02-28T12:12:29.000Z</updated>
        <content type="html"><![CDATA[<p>大家经常说“Go语言是为了并发而生”、“Go语言是高并发时代的C语言”，这是因为Go通过goroutine（go中的协程）实现语言层面支持并发，每个goroutine默认只需要8KB的堆栈空间，并且有强大的<a href="https://bettertxt.top/post/golang-scheduler/">Go调度器</a>，所以我们可以轻松开启上万个goroutine。那如果我们需要某些goroutine按照一定的逻辑顺序执行和结束，这么多goroutine如何控制呢？<br>
下面就介绍Go中控制并发的三种方式：channel、WaitGroup和context。</p>
<blockquote>
<p>文中所有代码均在Github[跟着示例代码学golang项目]https://github.com/meetbetter/go-programming)中，持续更新中。</p>
</blockquote>
<h1 id="channel">channel</h1>
<p>channel是Go语言CSP模式(Communicating Sequential Processes)的具体实现，用于在goroutine之间的通信，也可以控制多个goroutine的并发同步，并且channel是并发安全的。下面介绍channel控制并发goroutine的两个常用场景：</p>
<ol>
<li>有一个goroutine在做重复任务，永远不会退出，即死循环，那如果我们要从外部关闭它呢？传统的方式是增加一个全局变量做通知信号，goroutine不断地判断这个全局变量，当被通知关闭时就结束goroutine，但是这样做需要用读写锁来保证线程安全，而且也不符合Go语言CSP的思想，我们有更优雅的方式：channel + select。</li>
</ol>
<pre><code class="language-go">func main() {
	stop := make(chan bool)

	go func() {
		for {
			select {
			case &lt;-stop:
				fmt.Println(&quot;监控退出，停止了...&quot;)
				return
			default:
				fmt.Println(&quot;goroutine监控中...&quot;)
				time.Sleep(1 * time.Second)
			}
		}
	}()

	time.Sleep(10 * time.Second)
	fmt.Println(&quot;可以了，通知监控停止&quot;)
	stop &lt;- true
	//为了检测监控是否停止，如果没有监控输出，就表示停止了
	time.Sleep(5 * time.Second)

}
</code></pre>
<blockquote>
<p>本文主要介绍WaitGroup和context，更多的channel控制并发的场景可以参考我之前的文章<a href="https://bettertxt.top/post/go-channel/">Go channel应用</a>。</p>
</blockquote>
<h1 id="waitgroup">WaitGroup</h1>
<p>channel可以方便的通知一个goroutine结束，如果我们有一组goroutine需要控制结束呢？sync包下WaitGroup从名字就可以看出它的作用——等待一组goroutine全局结束才会继续往下执行。WaitGroup总共有三个方法：Add(delta int),Done(),Wait()。<br>
Add：添加或者减少等待goroutine的数量<br>
Done:相当于Add(-1)<br>
Wait:执行阻塞，直到所有的WaitGroup数量变成0。</p>
<pre><code class="language-go">func main() {
	var wg sync.WaitGroup

	wg.Add(10)

	for i := 0; i &lt; 10; i++ {
		go func(i int) {
			time.Sleep(1 * time.Second)
			fmt.Printf(&quot;%d号完成\n&quot;, i)
			wg.Done()
		}(i)
	}

	wg.Wait()
	fmt.Println(&quot;好了，大家都干完了，放工&quot;)
}
</code></pre>
<h1 id="context">context</h1>
<p>但是如果一组goroutine中又创建了很多的goroutine，甚至新的goroutine又创建了很多goroutine，一层层的嵌套下去，这个时候channel和WaitGroup都无能为力了。为了控制这种场景下的goroutine，我们需要使用context跟踪并控制他们。<br>
context中文译作上下文，用在这儿非常贴切，利用goroutine的上下文关系来控制他们结束。</p>
<h2 id="context接口及使用">context接口及使用</h2>
<p>context接口的定义如下：</p>
<pre><code class="language-go">type Context interface {
	Deadline() (deadline time.Time, ok bool)

	Done() &lt;-chan struct{}

	Err() error

	Value(key interface{}) interface{}
}
</code></pre>
<p>其中Deadline() 是获取设置的截止时间，下面会介绍截止时间如何设置，如果返回值ok==false表示没有设置截至时间，想要取消就需要通过context；<br>
Done()方法返回的是一个channel，平时阻塞不可读，当可读时说明外部已经发起了取消请求，Done()所在goroutine就可以进行资源回收并结束；<br>
Err()返回接口context取消的原因；<br>
Value(key interface{}) interface{}是获取context中key对应的值。</p>
<p>但是context接口并不需要我们手动创建，Golang中已经内置了2个：</p>
<pre><code class="language-go">func Background() Context {
	return background
}

func TODO() Context {
	return todo
}
</code></pre>
<p>这两个context返回值都是空的context，Background()一般用在main函数或者初始化的地方，作为根context；其他场景需要新建context接口就使用TODO()。</p>
<p>context相关的还有四个衍生函数，可以根据context创建子context：</p>
<pre><code class="language-go">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
func WithValue(parent Context, key, val interface{}) Context
</code></pre>
<p>WithCancel函数是最常用的，传入父context，它会返回一个子context接口和一个用来通知取消子context的函数；<br>
WithDeadline函数除了需要传入父context，还需要传入截止时间，也是返回一个子context接口和一个用来通知取消子context的函数，到了指定的截止时间会自动取消，我们也可以使用取消函数提前取消；<br>
WithTimeout函数和WithDeadline函数类似，只是传入的是超时的时间，指多少时间后自动取消，而不是指定的时间点，即一个是时间长度，一个是时间点。<br>
WithValue函数不是和取消相关的，而是通过context在goroutine之间传递一个key-value对，可以通过上面说的context.Value()方法获取。</p>
<p>下面来看一下这些函数如何使用吧！</p>
<h3 id="withcancel控制一个goroutine">WithCancel控制一个goroutine</h3>
<pre><code class="language-go">func main() {
	ctx, cancel := context.WithCancel(context.Background())
	go func(ctx context.Context) {
		for {
			select {
			case &lt;-ctx.Done():
				fmt.Println(&quot;监控退出，停止了...&quot;)
				return
			default:
				fmt.Println(&quot;goroutine监控中...&quot;)
				time.Sleep(2 * time.Second)
			}
		}
	}(ctx)

	time.Sleep(10 * time.Second)
	fmt.Println(&quot;可以了，通知监控停止&quot;)
	cancel()
	
	time.Sleep(5 * time.Second)

}
</code></pre>
<h3 id="withcancel控制多个goroutine">WithCancel控制多个goroutine</h3>
<pre><code class="language-go">func main() {
	ctx, cancel := context.WithCancel(context.Background())
	for i := 0; i &lt; 10; i++ {
		go watch(ctx, i)
	}

	time.Sleep(10 * time.Second)
	fmt.Println(&quot;可以了，通知监控停止&quot;)
	cancel()
	//为了检测监控是否停止，如果没有监控输出，就表示停止了
	time.Sleep(5 * time.Second)
}

func watch(ctx context.Context, i int) {
	for {
		select {
		case &lt;-ctx.Done():
			fmt.Println(i, &quot;监控退出，停止了...&quot;)
			return
		default:
			fmt.Printf(&quot;goroutine %d监控中...\n&quot;, i)
			time.Sleep(1 * time.Second)
		}
	}
}
</code></pre>
<h3 id="withtimeout">WithTimeout</h3>
<pre><code class="language-go">
func process() {
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	//释放资源
	defer cancel()

	ch := make(chan bool)

	go func() {
		time.Sleep(time.Second * 5)
		// time.Sleep(time.Second * 1)
		ch &lt;- true
	}()

	select {
	case &lt;-ctx.Done():
		fmt.Println(&quot;timeout!&quot;)
	case &lt;-ch:
		fmt.Println(&quot;chan closed.&quot;)
	}

}
func main() {
	process()
}
</code></pre>
<h3 id="withdeadline">WithDeadline</h3>
<pre><code class="language-go">func main() {
	// d := time.Now().Add(4 * time.Second)
	d := time.Now().Add(2 * time.Second)

	ctx, cancel := context.WithDeadline(context.Background(), d)

	defer cancel()

	select {
	case &lt;-time.After(3 * time.Second):
		fmt.Println(&quot;overslept&quot;)
	case &lt;-ctx.Done():
		fmt.Println(ctx.Err())
	}

}
</code></pre>
<h3 id="withvalue传递key-value">WithValue传递key-value</h3>
<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;time&quot;
)

var key string = &quot;go-programming&quot;

func main() {

	ctx, cancel := context.WithCancel(context.Background())
	valCtx := context.WithValue(ctx, key, &quot;https://github.com/meetbetter/go-programming&quot;)

	go watch(valCtx)
	time.Sleep(time.Second * 5)
	cancel()

	time.Sleep(time.Second * 2)
}

func watch(ctx context.Context) {

	for {
		select {
		case &lt;-ctx.Done():
			fmt.Println(&quot;收到value：&quot;, ctx.Value(key))
			return
		default:
			fmt.Println(&quot;github.com/meetbetter&quot;)
			time.Sleep(time.Second * 1)
		}
	}

}
</code></pre>
<p>使用context的原则：</p>
<ol>
<li>不要把Context放在结构体中传递，要直接以函数参数的方式传递</li>
</ol>
<blockquote>
<p>有人说传递时形参必须叫ctx，实测叫其他名字也可以。</p>
</blockquote>
<ol start="2">
<li>以Context作为参数的函数方法，应该把Context作为第一个参数，放在第一位。</li>
<li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO</li>
<li>Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递</li>
<li>Context是线程安全的，可以放心的在多个goroutine中传递</li>
</ol>
<p>https://www.flysnow.org/2017/05/12/go-in-action-go-context.html<br>
https://www.kancloud.cn/liupengjie/go/577494</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go调度器介绍和容易忽视的问题]]></title>
        <id>https://meetbetter.github.io/post/golang-scheduler</id>
        <link href="https://meetbetter.github.io/post/golang-scheduler">
        </link>
        <updated>2019-02-01T07:31:17.000Z</updated>
        <content type="html"><![CDATA[<p>本文记录了本人对Golang调度器的理解和跟踪调度器的方法，特别是一个容易忽略的goroutine执行顺序问题，看了很多篇Golang调度器的文章都没提到这个点，分享出来一起学习，欢迎交流指正。</p>
<p><img src="https://i.loli.net/2019/07/31/5d41387a2d73492186.jpg" alt=""></p>
<h1 id="什么是调度器">什么是调度器</h1>
<p>为了方便刚接触操作系统和高级语言的同学，先用大白话介绍下什么是调度器。<br>
调度，是将多个程序合理的安排到有限的CPU上来使得每个程序都能够得以执行，实现宏观的并发执行。比如我们的电脑CPU只有四核甚至双核，可是我们却可以在电脑上同时运行几十个程序，这就是操作系统调度器的功劳。但操作系统调度的是进程和线程，线程简单地说就是轻量级的进程，但是每个线程仍需要MB级别的内存，而且如果两个切换的线程在不同的进程中，还需要进程切换，会使CPU在调度这件事上花费大量时间。<br>
为了更合理的利用CPU，Golang通过goroutine原生支持高并发，goroutine是由go调度器在语言层面进行调度，将goroutine安排到线程上，可以更充分地利用CPU。</p>
<h1 id="golang的调度器">Golang的调度器</h1>
<p>Golang的调度器在runtime中实现，我们每个运行的程序执行前都会运行一个runtime负责调度goroutine，我们写的代码入口要在main包下的main函数中也是因为runtime.main函数会调用main.main。Golang的调度器在2012被重写过一次，现在使用的是新版的G-P-M调度器，但是我们还是先来看下老的G-M调度器，这样才可以更好的体会当前调度器的强大之处。</p>
<h2 id="g-m模型">G-M模型：</h2>
<p>下面是旧调度器的G-P模型：<br>
<img src="https://i.loli.net/2019/07/31/5d4108f2aef5b43754.png" alt=""><br>
M：代表线程，goroutine都是由线程来执行的；<br>
Global G Queue：全局goroutine队列，其中G就代表goroutine，所有M都从这个队列中取出goroutine来执行。<br>
这种模型比较简单，但是问题也很明显：</p>
<ol>
<li>多个M访问一个公共的全局G队列，每次都需要加互斥锁保护，造成激烈的锁竞争和阻塞；</li>
<li>局部性很差，即如果M1上的G1创建了G2，需要将G2交给M2执行，但G1和G2是相关的，最好放在同一个M上执行。</li>
<li>M中有mcache(内存分配状态)，消耗大量内存和较差的局部性。</li>
<li>系统调用syscall会阻塞线程，浪费不能合理的利用CPU。</li>
</ol>
<h2 id="g-p-m模型">G-P-M模型</h2>
<p>后来Go语言开发者改善了调度器为G-P-M模型，如下图：<br>
<img src="https://i.loli.net/2019/07/31/5d4110155291e41796.png" alt=""><br>
其中G还是代表goroutine，M代表线程，全局队列依然存在；而新增加的P代表逻辑processor，现在G的眼中只有P，在G的眼里P就是它的CPU。并且给每个P新增加了局部队列来保存本P要处理的goroutine。<br>
这个模型的调度方法如下;</p>
<ol>
<li>每个P有个局部队列，局部队列保存待执行的goroutine</li>
<li>每个P和一个M绑定，M是真正的执行P中goroutine的实体</li>
<li>正常情况下，M从绑定的P中的局部队列获取G来执行</li>
<li>当M绑定的P的的局部队列已经满了之后就会把goroutine放到全局队列</li>
<li>M是复用的，不需要反复销毁和创建，拥有work stealing和hand off策略保证线程的高效利用。</li>
<li>当M绑定的P的局部队列为空时，M会从其他P的局部队列中偷取G来执行，即work stealing；当其他P偷取不到G时，M会从全局队列获取到本地队列来执行G。</li>
<li>当G因系统调用(syscall)阻塞时会阻塞M，此时P会和M解绑即hand off，并寻找新的idle的M，若没有idle的M就会新建一个M。</li>
<li>当G因channel或者network I/O阻塞时，不会阻塞M，M会寻找其他runnable的G；当阻塞的G恢复后会重新进入runnable进入P队列等待执行</li>
<li>mcache(内存分配状态)位于P，所以G可以跨M调度，不再存在跨M调度局部性差的问题</li>
<li>G是抢占调度。不像操作系统按时间片调度线程那样，Go调度器没有时间片概念，G因阻塞和被抢占而暂停，并且G只能在函数调用时有可能被抢占，极端情况下如果G一直做死循环就会霸占一个P和M，Go调度器也无能为力。</li>
</ol>
<h1 id="go调度器奇怪的执行顺序">Go调度器奇怪的执行顺序</h1>
<p>是不是感觉自己对Go调度器工作原理已经有个初步的了解了？下面指出一个坑给你踩一下，小心了！<br>
请看下面这段代码输出什么：</p>
<pre><code class="language-go">func main() {

	done := make(chan bool)

	values := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
	for _, v := range values {
		fmt.Println(&quot;---&gt;&quot;, v)
		go func(u string) {
			fmt.Println(u)
			done &lt;- true
		}(v)
	}

	// wait for all goroutines to complete before exiting
	for _ = range values {
		&lt;-done
	}

}
</code></pre>
<p>先仔细想一下再看答案哦！</p>
<p><img src="https://i.loli.net/2019/07/31/5d41387a2d73492186.jpg" alt=""></p>
<p>实际的数据结果是：</p>
<pre><code class="language-go">---&gt; a
---&gt; b
---&gt; c
c
b
a
</code></pre>
<blockquote>
<p>Go调度器示例代码可以在<a href="https://github.com/meetbetter/go-programming/tree/master/02_advance/09_Go-Schedule">跟着示例代码学golang</a>中查看。</p>
</blockquote>
<p>可能你的第一反应是“不应该是输出a,b,c,吗？为什么输出是c,a,b呢？”<br>
这里我们虽然是使用for循环创建了3个goroutine，而且创建顺序是a,b,c，按之前的分析应该是将a,b,c三个goroutine依次放进P的局部队列，然后按照顺序依次执行a,b,c所在的goroutine，为什么每次都是先执行c所在的goroutine呢？这是因为同一逻辑处理器中三个任务被创建后 理论上会按顺序 被放在同一个任务队列，但实际上最后那个任务会被放在专一的next（下一个要被执行的任务的意思）的位置，所以优先级最高，最可能先被执行，所以表现为<strong>在同一个goroutine中创建的多个任务中最后创建那个任务最可能先被执行</strong>。</p>
<blockquote>
<p>这段解释来自参考文章《Goroutine执行顺序讨论》中。</p>
</blockquote>
<h1 id="调度器状态的查看方法">调度器状态的查看方法</h1>
<p>GODEBUG这个Go运行时环境变量很是强大，通过给其传入不同的key1=value1,key2=value2… 组合，Go的runtime会输出不同的调试信息，比如在这里我们给GODEBUG传入了”schedtrace=1000″，其含义就是每1000ms，打印输出一次goroutine scheduler的状态。<br>
下面演示使用Golang强大的GODEBUG环境变量可以查看当前程序中Go调度器的状态：</p>
<blockquote>
<p>环境为Windows10的Linux子系统(WSL)，WSL搭建和使用的代码在<a href="https://github.com/meetbetter/go-programming/blob/master/00_start/02_Windows10-Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.md">learn-golang项目</a>有整理，代码在文末参考的鸟窝的文章中也可以找到。</p>
</blockquote>
<pre><code class="language-go">func main() {
   var wg sync.WaitGroup
   wg.Add(10)
   for i := 0; i &lt; 10; i++ {
   	go work(&amp;wg)
   }
   wg.Wait()
   // Wait to see the global run queue deplete.
   time.Sleep(3 * time.Second)
}
func work(wg *sync.WaitGroup) {

   time.Sleep(time.Second)
   var counter int
   for i := 0; i &lt; 1e10; i++ {
   	counter++
   }
   wg.Done()
}
</code></pre>
<p>编译指令：</p>
<pre><code class="language-shell">go build 01_GODEBUG-schedtrace.go
GODEBUG=schedtrace=1000 ./01_GODEBUG-schedtrace
</code></pre>
<p>结果：</p>
<pre><code class="language-shell">SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=5 spinningthreads=1 idlethreads=0 runqueue=0 [4 0 4 0]
SCHED 1000ms: gomaxprocs=4 idleprocs=4 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 2007ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 3025ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 4033ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 5048ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 6079ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 7081ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 8092ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 9113ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 10129ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 11134ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 12157ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 13170ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 14183ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 15187ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 16187ms: gomaxprocs=4 idleprocs=2 threads=8 spinningthreads=0 idlethreads=5 runqueue=0 [0 0 0 0]
SCHED 17190ms: gomaxprocs=4 idleprocs=2 threads=8 spinningthreads=0 idlethreads=5 runqueue=0 [0 0 0 0]
SCHED 18193ms: gomaxprocs=4 idleprocs=2 threads=8 spinningthreads=0 idlethreads=5 runqueue=0 [0 0 0 0]
SCHED 19196ms: gomaxprocs=4 idleprocs=2 threads=8 spinningthreads=0 idlethreads=5 runqueue=0 [0 0 0 0]
SCHED 20200ms: gomaxprocs=4 idleprocs=4 threads=8 spinningthreads=0 idlethreads=6 runqueue=0 [0 0 0 0]
SCHED 21210ms: gomaxprocs=4 idleprocs=4 threads=8 spinningthreads=0 idlethreads=6 runqueue=0 [0 0 0 0]
SCHED 22219ms: gomaxprocs=4 idleprocs=4 threads=8 spinningthreads=0 idlethreads=6 runqueue=0 [0 0 0 0]
</code></pre>
<p>看到怎么多输出不要慌， 了解每个字段的含义就很清晰了：</p>
<ul>
<li>SCHED 1000ms<br>
自程序运行开始经历的时间</li>
<li>gomaxprocs=4<br>
当前程序使用的逻辑processor，即P，小于等于CPU的核数。</li>
<li>idleprocs=4<br>
空闲的线程数</li>
<li>threads=8<br>
当前程序的总线程数M，包括在执行G的和空闲的</li>
<li>spinningthreads=0<br>
处于自旋状态的线程，即M在绑定的P的局部队列和全局队列都没有G，M没有销毁而是在四处寻觅有没有可以steal的G，这样可以减少线程的大量创建。</li>
<li>idlethreads=3<br>
处于idle空闲状态的线程</li>
<li>runqueue=0<br>
全局队列中G的数目</li>
<li>[0 0 0 6]<br>
本地队列中的每个P的局部队列中G的数目，我的电脑是四核所有有四个P。</li>
</ul>
<p>上面的输出信息已经足够我们了解我们的程序运行状况，要想看每个goroutine、m和p的详细调度信息，可以在GODEBUG时加入，<code>scheddetail</code>：</p>
<pre><code class="language-shell">GODEBUG=schedtrace=1000,scheddetail=1 ./01_GODEBUG-schedtrace
</code></pre>
<p>结果如下：</p>
<pre><code class="language-shell">SCHED 0ms: gomaxprocs=4 idleprocs=4 threads=7 spinningthreads=0 idlethreads=2 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0
 P0: status=0 schedtick=7 syscalltick=1 m=-1 runqsize=0 gfreecnt=0
 P1: status=0 schedtick=2 syscalltick=1 m=-1 runqsize=0 gfreecnt=0
 P2: status=0 schedtick=1 syscalltick=1 m=-1 runqsize=0 gfreecnt=0
 P3: status=0 schedtick=1 syscalltick=1 m=-1 runqsize=0 gfreecnt=0
 M6: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 M5: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 M4: p=-1 curg=33 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 M3: p=-1 curg=49 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 M2: p=-1 curg=17 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1
 M0: p=-1 curg=14 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 G1: status=4(semacquire) m=-1 lockedm=-1
 G2: status=4(force gc (idle)) m=-1 lockedm=-1
 G3: status=4(GC sweep wait) m=-1 lockedm=-1
 G4: status=4(sleep) m=-1 lockedm=-1
 G5: status=4(sleep) m=-1 lockedm=-1
 G6: status=4(sleep) m=-1 lockedm=-1
 G7: status=4(sleep) m=-1 lockedm=-1
 G8: status=4(sleep) m=-1 lockedm=-1
 G9: status=4(sleep) m=-1 lockedm=-1
 G10: status=4(sleep) m=-1 lockedm=-1
 G11: status=4(sleep) m=-1 lockedm=-1
 G12: status=4(sleep) m=-1 lockedm=-1
 G13: status=4(sleep) m=-1 lockedm=-1
 G14: status=3() m=0 lockedm=-1
 G33: status=3() m=4 lockedm=-1
 G17: status=3() m=2 lockedm=-1
 G49: status=3() m=3 lockedm=-1
</code></pre>
<p>完整代码可以在<a href="https://github.com/meetbetter/go-programming/tree/master/02_advance/09_Go-Schedule">跟着示例代码学golang</a>中查看，持续更新中，想系统学习Golang的同学可以关注一下。</p>
<p>参考资料：<br>
<a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&amp;mid=2247483869&amp;idx=1&amp;sn=bf6f038dbe6c7bde5954fc37c0e449b5&amp;scene=21#wechat_redirect">大彬Go调度器系列</a></p>
<p><a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">也谈goroutine调度器</a></p>
<p><a href="https://colobu.com/2016/04/19/Scheduler-Tracing-In-Go/">鸟窝 Go调度器跟踪</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/27056944">Go调度器详解</a></p>
<p><a href="https://gocn.vip/question/1117">Goroutine执行顺序讨论</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搞懂Golang GC]]></title>
        <id>https://meetbetter.github.io/post/golang-GC</id>
        <link href="https://meetbetter.github.io/post/golang-GC">
        </link>
        <updated>2018-12-30T15:28:38.000Z</updated>
        <content type="html"><![CDATA[<p>本文主要介绍了垃圾回收的概念，Golang GC的垃圾回收算法和工作原理，看完本文可以让你对Golang垃圾回收机制有个全面的理解。由于本人不了解其他语言的GC，并未对比其他语言的垃圾回收算法，需要的可以自行Google。</p>
<h1 id="什么是垃圾回收">什么是垃圾回收</h1>
<p>垃圾回收（英语：Garbage Collection，缩写为GC），在计算机科学中是一种自动的存储器管理机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为垃圾回收。垃圾回收器可以让程序员减轻许多负担，也减少程序员犯错的机会。来自<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">维基百科</a></p>
<p>简单地说，<strong>垃圾回收(GC)是在后台运行一个守护线程，它的作用是在监控各个对象的状态，识别并且丢弃不再使用的对象来释放和重用资源。</strong></p>
<h1 id="go的垃圾回收">go的垃圾回收</h1>
<p>当前Golang使用的垃圾回收机制是<strong>三色标记发</strong>配合<strong>写屏障</strong>和<strong>辅助GC</strong>，三色标记法是<strong>标记-清除法</strong>的一种增强版本。</p>
<h2 id="标记-清除法mark-and-sweep">标记-清除法（mark and sweep）</h2>
<p>原始的标记清楚法分为两个步骤：</p>
<ol>
<li>标记。先STP(Stop The World)，暂停整个程序的全部运行线程，将被引用的对象打上标记</li>
<li>清除没有被打标机的对象，即回收内存资源，然后恢复运行线程。</li>
</ol>
<p>这样做有个很大的问题就是要通过STW保证GC期间标记对象的状态不能变化，整个程序都要暂停掉，在外部看来程序就会卡顿。</p>
<h2 id="三色标记法">三色标记法</h2>
<p>三色标记法是对标记阶段的改进，原理如下：</p>
<ol>
<li>初始状态所有对象都是白色。</li>
<li>从root根出发扫描所有根对象（下图a,b），将他们引用的对象标记为灰色（图中A，B）</li>
</ol>
<blockquote>
<p>那么什么是root呢？<br>
看了很多文章都没解释这这个概念，在这儿说明下：root区域主要是程序运行到当前时刻的栈和全局数据区域。</p>
</blockquote>
<p><img src="https://meetbetter.github.io/post-images/1564319758848.png" alt=""><br>
3.  分析灰色对象是否引用了其他对象。如果没有引用其它对象则将该灰色对象标记为黑色（上图中A）；如果有引用则将它变为黑色的同时将它引用的对象也变为灰色（上图中B引用了D）<br>
4. 重复步骤3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。</p>
<p>也可以参考下面的动图辅助理解：<br>
<img src="https://meetbetter.github.io/post-images/1563296640046.gif" alt=""></p>
<h2 id="go-gc如何工作">Go GC如何工作</h2>
<p>上面介绍的是GO GC采用的三色标记算法，但是好像并没有体现出来怎么减少STW对程序的影响呢？其实是因为<strong>Golang GC的大部分处理是和用户代码并行的</strong>。</p>
<p>GC期间用户代码可能会改变某些对象的状态，如何实现GC和用户代码并行呢？先看下GC工作的完整流程：</p>
<ol>
<li>Mark: 包含两部分:</li>
</ol>
<ul>
<li>Mark Prepare: 初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等。<strong>这个过程需要STW</strong></li>
<li>GC Drains: 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针（扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。<strong>该过程后台并行执行</strong></li>
</ul>
<ol start="2">
<li>Mark Termination: 完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下。<strong>这个过程也是会STW的。</strong></li>
<li>Sweep: 按照标记结果回收所有的白色对象，<strong>该过程后台并行执行</strong></li>
<li>Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。<br>
如果标记期间用户逻辑改变了刚打完标记的对象的引用状态，怎么办呢？</li>
</ol>
<h2 id="写屏障write-barrier">写屏障(Write Barrier)</h2>
<p>写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。<br>
好难懂哦，结合上面GC工作的完整流程就好理解了，就是在每一轮GC开始时会初始化一个叫做“屏障”的东西，然后由它记录第一次scan时各个对象的状态，以便和第二次re-scan进行比对，引用状态变化的对象被标记为灰色以防止丢失，将屏障前后状态未变化对象继续处理。</p>
<h2 id="辅助gc">辅助GC</h2>
<p>从上面的GC工作的完整流程可以看出Golang GC实际上把单次暂停时间分散掉了，本来程序执⾏可能是“⽤户代码--&gt;⼤段GC--&gt;⽤户代码”，那么分散以后实际上变成了“⽤户代码--&gt;⼩段 GC--&gt;⽤户代码--&gt;⼩段GC--&gt;⽤户代码”这样。如果GC回收的速度跟不上用户代码分配对象的速度呢？<br>
Go 语⾔如果发现扫描后回收的速度跟不上分配的速度它依然会把⽤户逻辑暂停，⽤户逻辑暂停了以后也就意味着不会有新的对象出现，同时会把⽤户线程抢过来加⼊到垃圾回收⾥⾯加快垃圾回收的速度。这样⼀来原来的并发还是变成了STW，还是得把⽤户线程暂停掉，要不然扫描和回收没完没了了停不下来，因为新分配对象⽐回收快，所以这种东⻄叫做辅助回收。</p>
<h2 id="如何进行gc调优">如何进行GC调优</h2>
<p>衡量GC对程序的影响可以参考这篇文章，<a href="https://www.oschina.net/translate/debugging-performance-issues-in-go-programs">Go 程序的性能调试问题</a>。<br>
减少对象的分配，合理重复利用；<br>
避免string与[]byte转化；</p>
<blockquote>
<p>两者发生转换的时候，底层数据结结构会进行复制，因此导致 gc 效率会变低。</p>
</blockquote>
<p>少量使用+连接 string；</p>
<blockquote>
<p>Go里面string是最基础的类型，是一个只读类型，针对他的每一个操作都会创建一个新的string。<br>
如果是少量小文本拼接，用 “+” 就好；如果是大量小文本拼接，用 strings.Join；如果是大量大文本拼接，用 bytes.Buffer。</p>
</blockquote>
<h2 id="gc触发条件">GC触发条件</h2>
<p>自动垃圾回收的触发条件有两个：</p>
<ol>
<li>超过内存大小阈值</li>
<li>达到定时时间<br>
阈值是由一个gcpercent的变量控制的,当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。<br>
如果一直达不到内存大小的阈值呢？这个时候GC就会被定时时间触发，比如一直达不到10M，那就定时（默认2min触发一次）触发一次GC保证资源的回收。</li>
</ol>
<h1 id="写在最后">写在最后</h1>
<p>虽然Golang有自动垃圾回收机制，但是GC不是万能的，最好还是养成手动回收内存的习惯：比如手动把不再使用的内存释放，把对象置成nil，也可以考虑在合适的时候调用runtime.GC()触发GC。</p>
<p>近期在维护的go学习示例代码，新手朋友们可以关注下<a href="https://github.com/meetbetter/go-programming">go-programming</a></p>
<p>参考：<br>
<a href="https://gocn.vip/question/265">string讨论</a><br>
<a href="https://www.jianshu.com/p/8b0c0f7772da">Go语言——垃圾回收GC</a><br>
<a href="https://mp.weixin.qq.com/s/Wh7A6czDIRofxveY_bEDNQ">Golang 垃圾回收剖析</a><br>
<a href="https://blog.csdn.net/u010649766/article/details/80582153">Golang垃圾回收机制详解</a><br>
<a href="https://lihaoquan.me/2016/11/3/go-gc-general.html">go垃圾回收概要</a><br>
<a href="https://wudaijun.com/2017/12/gc-study/">常见GC算法及Golang GC</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go RPC对比和示例]]></title>
        <id>https://meetbetter.github.io/post/go-rpc-learning</id>
        <link href="https://meetbetter.github.io/post/go-rpc-learning">
        </link>
        <updated>2018-11-29T08:14:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="说明">说明</h1>
<p>做项目中发现自己对很多东西的理解有偏差，所以决定做个总结，也分享给需要的朋友。如有错误和遗漏，欢迎沟通交流。</p>
<p><a href="https://github.com/meetbetter/gRPC-Demo">GitHub示例源码</a></p>
<p>本文介绍了Go中原生和第三方RPC使用方法，环境搭建方法并提供了材料。</p>
<h1 id="rpc">RPC</h1>
<p>远程过程调用(Remote Procedure Call)，通俗的说，RPC可以实现跨机器、跨语言调用其他计算机的程序。举个例子，我在机器A上用C语言封装了某个功能的函数，我可以通过RPC在机器B上用GO语言调用机器A上的指定函数。<br>
RPC为C/S模型，通常使用TCP或http协议。</p>
<h1 id="golang官方rpc">Golang官方RPC</h1>
<p>go RPC可以利用tcp或http来传递数据，可以对要传递的数据使用多种类型的编解码方式。</p>
<h2 id="netrpc库">net/rpc库</h2>
<p>Golang官方的net/rpc库可以通过tcp或http传递数据，但net/rpc库使用encoding/gob进行编解码，支持tcp或http数据传输方式，由于其他语言不支持gob编解码方式，所以使用net/rpc库实现的RPC方法没办法进行跨语言调用。</p>
<h3 id="server端代码">server端代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;net&quot;
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type Chen struct {
}

//rcp方法
//func (t *T) MethodName(argType T1, replyType *T2) error
func (this *Chen) GetAdd(data int, sum *int) error {

	*sum = data + 100

	return nil
}

func main() {
	//1.对象实例化
	pd := new(Chen)
	//2. rpc注册
	rpc.Register(pd)
	//3. rpc网络
	rpc.HandleHTTP()
	//4. 监听网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}
	//5. 等待连接
	http.Serve(ln, nil)
}
</code></pre>
<h3 id="client代码">client代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;fmt&quot;
)

func main() {
	//1. 连接服务器
	cln, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;rpc.Dial error:&quot;, err)
		return
	}
	defer cln.Close()

	//2. 调用服务器函数
	var data int
	err = cln.Call(&quot;Chen.GetAdd&quot;,10, &amp;data)
	if err != nil {
		fmt.Println(&quot;cln.Call error:&quot;, err)
		return
	}
	//3. 打印输出
	fmt.Println(&quot;计算结果为:&quot;, data)
}
</code></pre>
<h3 id="运行结果">运行结果</h3>
<p>客户端输出：<code>计算结果为: 110</code></p>
<h2 id="netrpcjsonrpc库">net/rpc/jsonrpc库</h2>
<p>Go官方还提供了使用json编解码的rpc库：net/rpc/jsonrpc，但是使用tcp传递数据，不能用http。</p>
<h3 id="server代码">server代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;net&quot;
	&quot;fmt&quot;
	&quot;net/rpc/jsonrpc&quot;
)

type Chen struct {
}

//rcp方法
//func (t *T) MethodName(argType T1, replyType *T2) error
func (this *Chen) GetAdd(data int, sum *int) error {

	*sum = data + 100

	return nil
}

func main() {
	//1.对象实例化
	pd := new(Chen)
	//2. rpc注册
	rpc.Register(pd)

	//3. 监听网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}

	//4. 处理客户端请求
	for {
		conn, err := ln.Accept()
		if err != nil {
			fmt.Println(&quot;Accept error:&quot;, err)
			continue
		}

		go func(conn net.Conn) {
			jsonrpc.ServeConn(conn)
		}(conn)
	}
}
</code></pre>
<h3 id="client代码-2">client代码</h3>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;net/rpc/jsonrpc&quot;
)

func main() {
	//1. 连接服务器
	cln, err := jsonrpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;jsonrpc.Dial error:&quot;, err)
		return
	}
	defer cln.Close()

	//2. 调用服务器函数
	var data int
	err = cln.Call(&quot;Chen.GetAdd&quot;,10, &amp;data)
	if err != nil {
		fmt.Println(&quot;cln.Call error:&quot;, err)
		return
	}
	//3. 打印输出
	fmt.Println(&quot;计算结果为:&quot;, data)
}
</code></pre>
<h3 id="运行结果-2">运行结果</h3>
<p>客户端输出：<code>计算结果为: 110</code></p>
<h1 id="grpc">gRPC</h1>
<p>所以为了真正实现跨主机、跨语言的远程调用，需要使用第三方的RPC库，推荐使用谷歌开源的gRPC。gRPC基于HTTP/2，采用protobuf进行数据编解码，压缩和传输效率更高。可以参考本人的<a href="https://github.com/meetbetter/protocol-buffer-demo">Go语言protobuf入门</a>了解Go语言protobuf的环境搭建和使用。</p>
<h2 id="grpc安装">gRPC安装</h2>
<p>由于不能直接访问golang官网，所以安装gPRC和go扩展包比较麻烦，可以从本人<a href="https://github.com/meetbetter/gRPC-Demo">gRPC环境包安装</a>中获取压缩包。</p>
<pre><code class="language-shell">unzip x.zip -d /$GOPATH/src/golang.org/x
unzip google.golang.org.zip -d /$GOPATH/src/google.golang.org
</code></pre>
<h2 id="grpc环境测试">gRPC环境测试</h2>
<p>启动服务器端，</p>
<pre><code class="language-shell">$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld/greeter_server
$ go run main.go
</code></pre>
<p>启动客户端，</p>
<pre><code class="language-shell">$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld/greeter_client
$ go run main.go
</code></pre>
<p>如果客户端打印出<code>2019/06/10 15:26:12 Greeting: Hello world</code>字样即表示gRPC环境正常。</p>
<h2 id="建立proto文件">建立proto文件</h2>
<pre><code class="language-protobuf">//版本
syntax = &quot;proto3&quot;;

//包名
package myproto;

//服务
service Hello {
    //这儿注释才有效
    rpc GetAdd(In)returns(Out);//这儿注释无效
}

//传入
message In {
    //此处1不是赋值，而是指参数序号
    int64 num = 1;
}

//传出
message Out {
    //此处1不是赋值，而是指参数序号
    int64 size = 1;
}
</code></pre>
<h2 id="生成go代码">生成go代码</h2>
<p>在.proto文件所在目录执行下面的指令，</p>
<pre><code class="language-shell">protoc --go_out=plugins=grpc:./ *.proto
</code></pre>
<blockquote>
<p>生成go代码时要指定plugins=grpc表示生成的是gRPC代码。</p>
</blockquote>
<h2 id="服务端代码">服务端代码</h2>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	pb &quot;gRPC/myproto&quot; //给package起别名
	&quot;context&quot;
	&quot;net&quot;
	&quot;google.golang.org/grpc&quot;
)

//1. 结构体
type Chen struct {

}

//2. 该结构体实现HelloServer interface的方法
func (this *Chen)GetAdd(ctx context.Context, In *pb.In)(*pb.Out,error)  {
	return &amp;pb.Out{Size:In.Num+100},nil
}

func main() {
	fmt.Println(&quot;server runing...&quot;)

	//3. 创建网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12345&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}
	defer ln.Close()

	//4. 创建gRPC句柄
	srv := grpc.NewServer()

	//5. 注册server
	pb.RegisterHelloServer(srv, &amp;Chen{})

	//6. 等待网络连接
	err = srv.Serve(ln)
	if err != nil {
		fmt.Println(&quot;srv.Serve error:&quot;, err)
		return
	}

}
</code></pre>
<h2 id="客户端代码">客户端代码</h2>
<pre><code class="language-go">package main

import (
	&quot;google.golang.org/grpc&quot;
	&quot;fmt&quot;
	pb &quot;gRPC/myproto&quot;
	&quot;context&quot;
)

func main() {
	//1 连接服务器
	conn, err := grpc.Dial(&quot;127.0.0.1:12345&quot;,grpc.WithInsecure())//grpc.WithInsecure()指定后才不会报错
	if err != nil {
		fmt.Println(&quot;grpc.Dial error:&quot;, err)
		return
	}
	defer conn.Close()

	//2 创建客户端句柄
	cln := pb.NewHelloClient(conn)

	//3 调用服务器函数(RPC)
	out,err := cln.GetAdd(context.Background(), &amp;pb.In{Num:10})
	if err != nil {
		fmt.Println(&quot;grpc.Dial error:&quot;, err)
		return
	}

	//4 打印
	fmt.Println(&quot;得到数据:&quot;, out.Size)
}

</code></pre>
<h2 id="运行测试">运行测试</h2>
<p>先后运行服务器和客户端代码，可在客户端打印输出<code>得到数据: 110</code>，说明已经成功在客户端调用服务端程序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang protobuf快速上手]]></title>
        <id>https://meetbetter.github.io/post/go-protobuf</id>
        <link href="https://meetbetter.github.io/post/go-protobuf">
        </link>
        <updated>2018-11-20T08:08:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="说明">说明</h1>
<p><a href="https://github.com/meetbetter/protocol-buffer-demo">Demo源码</a></p>
<p>protocol buffer是谷歌推出的高效率序列化反序列化工具，可以自定义数据结构，然后使用对应语言的代码生成器生成的代码读写这个数据结构。虽然在和前端打交道时还是要配合使用JSON，但是在其他场合可以尝试使用protocol buffer改进性能。</p>
<p>下面总结下在GoLang中使用protocol buffer的方法。</p>
<h1 id="go环境配置">Go环境配置</h1>
<h2 id="下载protobuf">下载protobuf</h2>
<pre><code class="language-shell">git clone https://github.com/protocolbuffers/protobuf.git
</code></pre>
<h2 id="安装linux-ubuntu">安装(Linux Ubuntu)</h2>
<h3 id="1安装依赖工具">(1)安装依赖工具</h3>
<pre><code class="language-shell">sudo apt-get install autoconf automake libtool curl make g++ unzip libffi-dev -y
</code></pre>
<h3 id="2进入protobuf文件">(2)进入protobuf文件</h3>
<pre><code class="language-shell">cd protobuf/
</code></pre>
<h3 id="3进行安装检测-并生成自动安装脚本">(3)进行安装检测 并生成自动安装脚本</h3>
<pre><code class="language-shell">./autogen.sh
./configure
</code></pre>
<h3 id="4进行编译c代码和安装">(4)进行编译C代码和安装</h3>
<pre><code class="language-shell">make
sudo make install
</code></pre>
<h3 id="5刷新linux共享库关系">(5)刷新linux共享库关系</h3>
<pre><code class="language-shell">sudo ldconfig
</code></pre>
<h3 id="6测试protobuf编译工具">(6)测试protobuf编译工具</h3>
<pre><code class="language-shell">protoc -h
</code></pre>
<p>如果正常输出 相关指令 没有报任何error，为安装成功。</p>
<h2 id="获取-golang的proto包">获取 GoLang的proto包</h2>
<h3 id="1下载">(1)下载</h3>
<pre><code class="language-shell">go get -v -u github.com/golang/protobuf/proto
</code></pre>
<h3 id="2进入到文件夹内进行编译">(2)进入到文件夹内进行编译</h3>
<pre><code class="language-shell">cd $GOPATH/src/github.com/golang/protobuf/protoc-gen-go/
go build
</code></pre>
<h3 id="3拷贝可执行文件">(3)拷贝可执行文件</h3>
<p>将生成的 protoc-gen-go可执行文件，放在/bin目录下。</p>
<pre><code class="language-shell">sudo cp protoc-gen-go /bin/
</code></pre>
<p>尝试补齐protoc-gen-go 如果可以补齐代表成功，如果执行不报错 代表工具成功。</p>
<h1 id="go使用protobuf">Go使用protobuf</h1>
<h2 id="新建proto文件">新建.proto文件</h2>
<p>基本格式如下：</p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;; //必须指定protobuf协议版本号
package pb; //包名

//定义一个protobuf协议
message Person {
    string name = 1; //数字表示序号，并不是变量值.
    int32 age = 2;
    repeated string hobby = 3; //对应go中[]string

}
</code></pre>
<h2 id="生成go数据结构">生成Go数据结构</h2>
<p>在.proto所在目录执行如下命令，</p>
<pre><code class="language-shell">protoc --go_out=.  *.proto
</code></pre>
<p>在当前目录下会生成对应的.go文件，可以在其中找到go的数据结构，</p>
<pre><code class="language-go">type Person struct {
	Name                 string   `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`
	Age                  int32    `protobuf:&quot;varint,2,opt,name=age,proto3&quot; json:&quot;age,omitempty&quot;`
	Hobby                []string `protobuf:&quot;bytes,3,rep,name=hobby,proto3&quot; json:&quot;hobby,omitempty&quot;`
	XXX_NoUnkeyedLiteral struct{} `json:&quot;-&quot;`
	XXX_unrecognized     []byte   `json:&quot;-&quot;`
	XXX_sizecache        int32    `json:&quot;-&quot;`
}
</code></pre>
<p><strong>注意</strong>，该文件只能生成不能手动修改。</p>
<h2 id="使用protobuf">使用protobuf</h2>
<p>在main函数中新建Person对象并进行序列化和反序列化，</p>
<pre><code class="language-go">package main

import (
	&quot;protobufDemo/pb&quot;
	&quot;github.com/golang/protobuf/proto&quot;
	&quot;fmt&quot;
)

func main() {

	//序列化
	person := &amp;pb.Person{
		Name:&quot;Jack&quot;,
		Age:18,
		Hobby:[]string{&quot;sing&quot;,&quot;dance&quot;,&quot;basketball&quot;,&quot;rap&quot;},
	}

	binaryData, err := proto.Marshal(person)
	if err != nil {
		fmt.Println(&quot;proto.Marshal err:&quot;,err)
	}

	//反序列化
	newPerson := &amp;pb.Person{}
	err = proto.Unmarshal(binaryData,newPerson)
	if err != nil {
		fmt.Println(&quot;proto.Unmarshal err:&quot;,err)
	}

	fmt.Println(&quot;序列化前的原始数据:&quot;,person)
	fmt.Println(&quot;反序列化得到数据:&quot;,newPerson)
}

</code></pre>
<p>执行后可以看到person和newPerson都喜欢<strong>唱、跳、篮球和rap</strong>。</p>
<pre><code class="language-shell">序列化前的原始数据: name:&quot;Jack&quot; age:18 hobby:&quot;sing&quot; hobby:&quot;dance&quot; hobby:&quot;basketball&quot; hobby:&quot;rap&quot; 
反序列化得到数据: name:&quot;Jack&quot; age:18 hobby:&quot;sing&quot; hobby:&quot;dance&quot; hobby:&quot;basketball&quot; hobby:&quot;rap&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解Golang channel]]></title>
        <id>https://meetbetter.github.io/post/go-channel</id>
        <link href="https://meetbetter.github.io/post/go-channel">
        </link>
        <updated>2018-10-02T11:16:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="channel是什么">channel是什么</h1>
<p>channel中文翻译成“管道”，很形象地体现出了channel的基本用途——传输数据的通道。<br>
channel的作用可以分为两个：</p>
<ol>
<li>在goroutine之间传输数据</li>
<li>同步，即goroutine调度<br>
channel是Golang CSP(Communicating Sequential Processes)的核心，即gopher常说的“通过通信来共享内存，而不是通过共享内存而通信”。</li>
</ol>
<h1 id="channel的类型">channel的类型</h1>
<p>channel按缓冲区可分为：</p>
<ol>
<li>无缓冲channel</li>
</ol>
<pre><code class="language-go">ch := make(chan int)
</code></pre>
<p>同步模式，channel的读写端必须同时在线，否则会阻塞。<br>
2. 有缓冲channel</p>
<pre><code class="language-go">ch := make(chan int, 100)
</code></pre>
<p>即异步模式，读写两端不必同时在线，在缓冲区满之前写端不会阻塞，在缓冲区数据被读完之前读端不会阻塞。</p>
<p>按数据流向可分为：</p>
<ol>
<li>双向channel，可读可写</li>
<li>只读channel</li>
<li>只写channel</li>
</ol>
<pre><code class="language-go">chan T //可以接收发送类型为T的双向channel
chan&lt;- T //只可以发送类型为T的只写channel
&lt;-chan T //只可以接收类型为T的只读channel
</code></pre>
<h1 id="channel的特性">channel的特性</h1>
<ul>
<li>往nil channel写数据会一直阻塞；</li>
<li>从nil channel读数据会一直阻塞；</li>
<li>往已经close的channel写数据会导致panic</li>
<li>从已经close的channel读数据会读到对应类型的零值</li>
<li>close一个已经close过的channel会导致panic。</li>
</ul>
<h1 id="channel应用">channel应用</h1>
<h2 id="同步">同步</h2>
<pre><code class="language-go">
package main

/*
	演示channel的同步作用
*/

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func send(done, quit chan bool) {
	//等待recv完成后由send关闭
	&lt;-done
	fmt.Println(&quot;那我关闭了哦&quot;)

	//通知main goroutine
	quit &lt;- true
}

func recv(done chan bool) {
	time.Sleep(time.Second)
	// 通知任务已完成
	fmt.Println(&quot;对面的send可以关闭了&quot;)
	done &lt;- true
}

func main() {
	done := make(chan bool)
	quit := make(chan bool)
	go send(done, quit)
	go recv(done)
	// 等待任务完成
	&lt;-quit
	fmt.Println(&quot;main也结束了哦&quot;)
}

</code></pre>
<h2 id="select读取多个channel">select读取多个channel</h2>
<p>select可以监听多个case上的IO流动，配合channel可以实现监听多个channel的数据：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func fibonacci(data, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case data &lt;- x:
			x, y = y, x+y
		case &lt;-quit:
			fmt.Println(&quot;quit&quot;)
			return
		}
	}
}
func main() {
	data := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i &lt; 20; i++ {
			fmt.Println(&lt;-data)
		}
		quit &lt;- 0
	}()
	fibonacci(data, quit)
}

</code></pre>
<h2 id="channel超时">channel超时</h2>
<p>channel超时未收到数据则关闭：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func selectFunc(data &lt;-chan string, quit chan bool) {

	for {

		select {
		case res := &lt;-data:
			fmt.Println(res)
		case &lt;-time.After(time.Second * 2): //其它case有数据时，select结束, time被重置
			fmt.Println(&quot;timeout ,will quit&quot;)
			&lt;-quit
		}
	}

}
func main() {
	data := make(chan string, 1)
	quit := make(chan bool)
	go selectFunc(data, quit)

	for i := 0; i &lt; 5; i++ {
		time.Sleep(time.Second)
		data &lt;- &quot;github.com/meetbetter&quot;
	}

	quit &lt;- true

}
</code></pre>
<h2 id="channel的关闭">channel的关闭</h2>
<p>当channel已经关闭之后，写端再往里写数据会导致panic，但是读端仍可以读，如果是无缓冲buffer，读端会读到对应类型的零值；如果是有缓冲buffer，写端关闭后读端仍可以读取数据，直到把数据读完才会读到零值。<br>
因为往已经close的channel中写数据会panic，所以最好由写端关闭channel，读端判断channel是否已关闭。那如何判断对端已关闭呢？<br>
可以使用返回值&quot;ok&quot;判断，如果写端已关闭channel，返回值&quot;ok&quot;会为false：</p>
<pre><code class="language-go">  if data, ok := &lt;-ch1; ok {
                fmt.Println(data)
            }
</code></pre>
<p>也可以使用range遍历，当写端关闭channel时，range会跳出循环：</p>
<pre><code class="language-go">  for data := range  ch1{
            fmt.Println(data)
        }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go“一个包含nil指针的接口不是nil接口”踩坑]]></title>
        <id>https://meetbetter.github.io/post/go-interface-nil</id>
        <link href="https://meetbetter.github.io/post/go-interface-nil">
        </link>
        <updated>2018-08-03T12:53:59.000Z</updated>
        <content type="html"><![CDATA[<p>最近在项目中踩了一个深坑——“Golang中一个包含nil指针的接口不是nil接口”，现象是函数内返回了nil给一个对象，使用interface接收函数返回值判断始终不为nil。总结下分享出来，如果你不是很理解这句话，那推荐认真看下下面的示例代码，避免以后写代码时踩坑。</p>
<h1 id="示例一">示例一</h1>
<p>先一起来看下这段代码，你感觉有没有问题呢？</p>
<pre><code class="language-go">type IPeople interface {
	hello()
}
type People struct {
}

func (p *People) hello() {
	fmt.Println(&quot;github.com/meetbetter&quot;)
}

func errFunc1(in int) *People {
	if in == 0 {
		fmt.Println(&quot;importantFunc返回了一个nil&quot;)
		return nil
	} else {
		fmt.Println(&quot;importantFunc返回了一个非nil值&quot;)
		return &amp;People{}
	}

}

func main() {
	var i IPeople

	in := 0

	i = errFunc1(in)

	if i == nil {

		fmt.Println(&quot;哈，外部接收到也是nil&quot;)
	} else {

		fmt.Println(&quot;咦，外部接收到不是nil哦&quot;)
		fmt.Printf(&quot;%v, %T\n&quot;, i, i)
	}

}
</code></pre>
<p>这段代码的执行结果是:</p>
<pre><code class="language-shell">importantFunc返回了一个nil
咦，外部接收到不是nil哦
&lt;nil&gt;, *main.People
</code></pre>
<p>可以看到在main函数中收到的返回值不是nil， 明明在errFunc1()函数中返回的是nil，到了main函数为什么收到的不是nil呢？<br>
这是因为：将nil赋值给<code>*People</code>后再将<code>*People</code>赋值给interface，<code>*People</code>本身是是个指向nil的指针，但是将其赋给接口时只是接口中的值为nil，但是接口中的类型信息为<code>*main.People</code>而不是nil，所以这个接口不是nil。<br>
是的，Golang中的interface类型包含两部分信息——值信息和类型信息，只有interface的值合并类型都为nil时interface才为nil，interface底层实现可以在后面的源码分析看到。</p>
<p>先来看看正确的处理接口返回值的方法，是直接将nil赋给interface：</p>
<pre><code class="language-go">
func rightFunc(in int) IPeople {
	if in == 0 {
		fmt.Println(&quot;importantFunc返回了一个nil&quot;)
		return nil
	} else {
		fmt.Println(&quot;importantFunc返回了一个非nil值&quot;)
		return &amp;People{}
	}

}
</code></pre>
<h1 id="示例二">示例二</h1>
<p>下面的代码更清晰的证明了<code>一个包含nil指针的接口不是nil接口</code>的结论：</p>
<pre><code class="language-go">type IPeople interface {
	hello()
}
type People struct {
}

func (p *People) hello() {
	fmt.Println(&quot;github.com/meetbetter&quot;)
}

//错误：将nil的people给空接口后接口就不为nil,因为interface中的value为nil但type不为nil

func errFunc() *People {

	return nil
}

//正确处理返回nil给接口的方法,返回时go就确定了接口是不是nil
func rightFunc() IPeople {

	return nil
}
func main() {

	var i IPeople
	i = errFunc()
	if i == nil { //想通过接口是否为nil来判断故障，却始终判断接口非空

		fmt.Println(&quot;errFunc对了哦，外部接收到也是nil&quot;)
		fmt.Println(reflect.TypeOf(i))
	} else {

		fmt.Println(&quot;errFunc错了咦，外部接收到不是nil哦&quot;)
		fmt.Println(reflect.TypeOf(i))
	}

	i = rightFunc()
	if i == nil {

		fmt.Println(&quot;rightFunc对了哦，外部接收到也是nil&quot;)
		fmt.Println(reflect.TypeOf(i))
	} else {

		fmt.Println(&quot;rightFunc错了咦，外部接收到不是nil哦&quot;)
		fmt.Println(reflect.TypeOf(i))

	}

}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">errFunc错了咦，外部接收到不是nil哦
*main.People
rightFunc对了哦，外部接收到也是nil
&lt;nil&gt;
</code></pre>
<h1 id="interface底层实现">interface底层实现</h1>
<p>下面的注释信息来自参考文章中，从interface底层实现可以看出iface比eface 中间多了一层itab结构， itab 存储_type信息和[]fun方法集，所以即使data指向了nil 并不代表interface 就是nil， 还要考虑_type信息。</p>
<pre><code class="language-go">type eface struct {      //空接口
    _type *_type         //类型信息
    data  unsafe.Pointer //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)
}
type iface struct {      //带有方法的接口
    tab  *itab           //存储type信息还有结构实现方法的集合
    data unsafe.Pointer  //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)
}
type _type struct {
    size       uintptr  //类型大小
    ptrdata    uintptr  //前缀持有所有指针的内存大小
    hash       uint32   //数据hash值
    tflag      tflag
    align      uint8    //对齐
    fieldalign uint8    //嵌入结构体时的对齐
    kind       uint8    //kind 有些枚举值kind等于0是无效的
    alg        *typeAlg //函数指针数组，类型实现的所有方法
    gcdata    *byte
    str       nameOff
    ptrToThis typeOff
}
type itab struct {
    inter  *interfacetype  //接口类型
    _type  *_type          //结构类型
    link   *itab
    bad    int32
    inhash int32
    fun    [1]uintptr      //可变大小 方法集合
}
</code></pre>
<p>以上完整代码均整理在<a href="https://github.com/meetbetter/learn-golang/tree/master/02_advance/11_nil-interface">Github-跟着示例代码学Golang项目</a>。</p>
<p>参考文章：</p>
<p><a href="https://studygolang.com/articles/10635">Golang第一大坑</a></p>
<p><a href="https://gocn.vip/question/1011">&quot;一个包含nil指针的接口不是nil接口&quot;的讨论</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang defer panic recover总结]]></title>
        <id>https://meetbetter.github.io/post/defer-panic-recover</id>
        <link href="https://meetbetter.github.io/post/defer-panic-recover">
        </link>
        <updated>2018-06-11T12:52:45.000Z</updated>
        <content type="html"><![CDATA[<p>总结下defer panic recover的用法和坑，如果你清楚他们的用法，那你可以看下最后的defer的坑，自查一下会不会掉进去。<br>
下面先介绍概念，再看代码。</p>
<p>defer关键字用来实现延迟处理和资源释放，如果一个函数中调用多个defer会出现类似栈的后入先出效果。defer可以用来优雅的关闭文件描述符，关闭socket连接，解锁操作等。<br>
panic是在程序运行时出现非常严重的错误时抛出异常，之后的函数不再执行，而是顺着原来的函数调用一层层的向上抛出直到main函数中导致进程挂掉——程序崩了。引起panic的原因有：数组访问越界、空指针引用、死锁等，当然还有手动调用panic()。<br>
但panic不是立即向上抛出异常，而是先执行之间已经defer的内容，这时候就可以在defer中拦截异常以保证其他任务不受影响。recover就是专门来做这个的捕手。</p>
<p>下面是他们的基本用法和那些一不注意就掉进去的坑。</p>
<h1 id="defer-的基本使用">defer 的基本使用</h1>
<p>先来看下defer的基本使用：</p>
<h2 id="defer延迟调用">defer延迟调用</h2>
<pre><code class="language-go">func f1() {
	defer fmt.Println(&quot;1111&quot;)

	fmt.Println(2222)
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">2222
1111
</code></pre>
<pre><code class="language-go">func f2() {
	i := 10
	defer func() {
		i = 100
	}()

	fmt.Println(&quot;i: &quot;, i)
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">i:  10
</code></pre>
<p>所以我们通常用defer来优雅的关闭文件描述符，解锁等操作：</p>
<pre><code class="language-go">func f4() error {
	f, err := os.Open(&quot;a.txt&quot;)
	if err != nil {
		return err
	}

	defer f.Close()

	return nil
}
</code></pre>
<h2 id="多个defer的后入先出">多个defer的后入先出</h2>
<p>多个defer的执行顺序：</p>
<pre><code class="language-go">func f1() {
	defer fmt.Println(&quot;1111&quot;)
	defer fmt.Println(&quot;2222&quot;)
	defer fmt.Println(&quot;3333&quot;)
	defer fmt.Println(&quot;4444&quot;)
}
</code></pre>
<p>输出结果是：</p>
<pre><code class="language-shell">4444
3333
2222
1111
</code></pre>
<h1 id="panic和recover">panic和recover</h1>
<p>首先看下panic的威力：</p>
<pre><code class="language-go">func f1() {
	fmt.Println(&quot;github.com/meetbetter/go-programming&quot;)
	panic(&quot;boom&quot;)
	fmt.Println(&quot;f1 end&quot;)
}
func main() {
	fmt.Println(&quot;main Entry&quot;)
	f1()
	fmt.Println(&quot;main End&quot;)

}
</code></pre>
<p>从下面的输出结果可以看出panic后会逐层上抛异常，并且panic后的程序得不到执行：</p>
<pre><code class="language-go">main Entry
github.com/meetbetter/go-programming
panic: boom

goroutine 1 [running]:
main.f1()
        /mnt/c/Users/HideOnBush/go/src/myProjects/00-leetcode/05_panic.go:7 +0x96
main.main()
        /mnt/c/Users/HideOnBush/go/src/myProjects/00-leetcode/05_panic.go:12 +0x7f
exit status 2
</code></pre>
<p>再来看看recover的威力，拦截panic异常抛出：</p>
<pre><code class="language-go">func f1() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err)
		}
	}()

	panic(&quot;github.com/meetbetter/go-programming&quot;)

	fmt.Println(&quot;看不到我哦&quot;)
}

func main() {
	f1()

	fmt.Println(&quot;main End&quot;)
}
</code></pre>
<h1 id="defer的那些坑">defer的那些坑</h1>
<h2 id="level1">level1</h2>
<p>先看下这个level1级别的坑：</p>
<pre><code class="language-go">func f() (result int) {
	defer func() {
		result++
	}()
	return 0
}

func main() {
	fmt.Println(f())

}
</code></pre>
<p>输出结果是100吗？<br>
不对，是101。这儿是因为return时分为两步：给返回值result赋值 --&gt; 执行defer。所以外面接收到的返回值是100+1。</p>
<h2 id="level2">level2</h2>
<p>再来看个level2的，下面的输出为什么不一样：</p>
<pre><code class="language-go">
func f1() {

	i := 0
	defer func(i int) {
		fmt.Println(&quot;defer func: &quot;, i)
	}(i)

	i = 100

}

func f2() {

	i := 0
	defer func() {
		fmt.Println(&quot;defer func: &quot;, i)
	}()

	i = 100

}
func main() {

	f1()
	f2()
}
</code></pre>
<p>输出结果是</p>
<pre><code>defer func:  0
defer func:  100
</code></pre>
<p>这是因为传递进f1中的参数i是局部变量，defer注册后，即使外面改变i也不会影响f1内部的参数了；f2输出100是因为defer中的i是全局变量，在外面改变时会影响到defer内的参数。</p>
<h2 id="level3">level3</h2>
<p>再来看这个level3的，test1()和test2()输出的结果一样吗？</p>
<pre><code class="language-go">
type message struct {
	content string
}

func (p *message) set(c string) {
	p.content = c
}

func (p *message) print1() string {
	//fmt.Println(&quot;print1 running&quot;)
	return p.content

}

func (p *message) print2() {
	//fmt.Println(&quot;print2 running&quot;)
	fmt.Println(p.content)

}

func test1() {
	m := &amp;message{content: &quot;Hello&quot;}

	defer fmt.Println(m.print1())

	m.set(&quot;World&quot;)

	//fmt.Println(&quot;call print1&quot;)
}

func test2() {
	m := &amp;message{content: &quot;Hello&quot;}

	defer m.print2()

	m.set(&quot;World&quot;)

	//fmt.Println(&quot;call print2&quot;)
}
</code></pre>
<p>结果是：test1输出<code>Hello</code>，test2输出<code>World</code>。可能test2输出<code>World</code>还好理解，因为相当于m中指向的内容被<code>m.set(&quot;World&quot;)</code>更改了;那么test1为什么输出<code>Hello</code>呢？这时因为调用print等输出函数时会先计算出结果，即使你后面再改变变量值对print也没有影响了。</p>
<p>以下所有代码均在整理在<a href="https://github.com/meetbetter/go-programming">github go programming</a>。</p>
]]></content>
    </entry>
</feed>