<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://meetbetter.github.io</id>
    <title>Betterman</title>
    <updated>2019-08-04T01:59:53.793Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://meetbetter.github.io"/>
    <link rel="self" href="https://meetbetter.github.io/atom.xml"/>
    <subtitle>记录自己，期望可以帮到需要的人</subtitle>
    <logo>https://meetbetter.github.io/images/avatar.png</logo>
    <icon>https://meetbetter.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Betterman</rights>
    <entry>
        <title type="html"><![CDATA[Github pages+gridea:超简单的搭建个人博客]]></title>
        <id>https://meetbetter.github.io/post/github-pages-gridea</id>
        <link href="https://meetbetter.github.io/post/github-pages-gridea">
        </link>
        <updated>2019-05-01T09:00:26.000Z</updated>
        <content type="html"><![CDATA[<p>最近用了一款叫做<a href="https://github.com/getgridea/gridea">Gridea</a>的静态博客客户端，非常间接美观，不再像之前使用Github pages的Jekyll时那么麻烦，能更好的关注于写作内容。期间也遇到一些问题，现在记录下来，希望需要的人能看到。</p>
<h1 id="github-pages搭建个人博客">github pages搭建个人博客</h1>
<p>首先，要知道<a href="https://pages.github.com/">GitHub pages</a>是托管在<a href="https://github.com/">GitHub</a>上的静态网页，现在已被很多github上的程序员当作个人博客，官方也很支持并提供了Jekyll模板，但是用起来比较麻烦。<br>
下面介绍下使用Gridea快速搭建Github pages的方法。<br>
搭配<a href="https://fehey.com/post/hve-notes-start/">Gridea作者的使用说明</a>服用效果更佳。</p>
<ol>
<li>首先你要有Github账号，没有的快去注册吧...</li>
<li><a href="https://github.com/new">创建Github pages仓库</a>，注意仓库名必须为<code>你的github用户名.github.io</code>，比如我的：<br>
<img src="https://meetbetter.github.io/post-images/1563189795874.png" alt=""></li>
</ol>
<blockquote>
<p>红色提示是因为我已有同名仓库，第一次创建不会有此提示。</p>
</blockquote>
<ol start="3">
<li>电脑安装<a href="https://git-scm.com/downloads">Git</a>，并且github要配置好ssh免登录，配置方法这儿不做介绍，需要自行解决。</li>
<li><a href="https://github.com/settings/tokens/new">点击这里</a>在Github中创建Token，为了安全切记<strong>只勾选repo全选</strong>：<br>
<img src="https://meetbetter.github.io/post-images/1563190238541.png" alt=""><br>
保存好生成的Token：<br>
<img src="https://meetbetter.github.io/post-images/1563190391143.png" alt=""></li>
<li>下载<a href="https://gridea.dev/">Gridea</a>，打开Gridea客户端，在配置中填写基础配置并保存<br>
<img src="https://meetbetter.github.io/post-images/1563190931089.png" alt=""></li>
<li>现在你就可以在Gridea编写文章并同步到github pages了，点击同步之后在浏览器输入<code>你的github用户名.github.io</code>就可以看到自己的博客了，比如这有个小菜鸡的博客<a href="https://meetbetter.github.io">https://meetbetter.github.io</a>。</li>
<li>到此，你已经拥有自己的博客了，快去分享自己写bug的经验吧。</li>
</ol>
<h1 id="域名绑定">域名绑定</h1>
<p>如果你想感觉<code>你的github用户名.github.io</code>不够简洁，或者想要拥有特定域名的博客，可以在阿里云、腾讯云、namesilo等购买域名，大家可以按需选择。下面是我以namesilo为例绑定github pages的方法。</p>
<h2 id="注册个人域名">注册个人域名</h2>
<p>创建账号并选择想要的域名，网上教程一大把，这儿不再做介绍。只需要在提交订单时注意以下部分就好：<br>
<img src="https://meetbetter.github.io/post-images/1563192573133.jpg" alt=""></p>
<h2 id="绑定个人域名">绑定个人域名</h2>
<p>选择右上角“Manage my Domains”，然后选择对应域名后的蓝色小球，进入DNS解析配置页面：<br>
<img src="https://meetbetter.github.io/post-images/1563192980005.png" alt=""><br>
从<a href="https://help.github.com/en/articles/setting-up-an-apex-domain#configuring-a-records-with-your-dns-provider">这个地址</a>查找最新的Github IP，按照下面的设置：<br>
<img src="https://meetbetter.github.io/post-images/1563193417614.png" alt=""><br>
IP填写<a href="https://help.github.com/en/articles/setting-up-an-apex-domain#configuring-a-records-with-your-dns-provider">这个地址</a>找到的最新IP，CNAME写<code>你的github用户名.github.io</code></p>
<blockquote>
<p>设置DNS解析服务器后可能需要几分钟甚至几个小时来同步，可以使用<a href="https://tool.chinaz.com/dns/?type=1&amp;host=bettertxt.top&amp;ip=">DNS查询</a>确认DNS是否配置正确。</p>
</blockquote>
<h2 id="设置cname">设置CNAME</h2>
<ol>
<li>Github pages设置CNAME<br>
在Github中选择<code>你的github用户名.github.io</code>的仓库中的setting，填写你购买的域名：<br>
<img src="https://meetbetter.github.io/post-images/1563193703574.png" alt=""><br>
域名前不加http或www修饰，记得勾选Enforce HTTPS，否则访问该域名会因缺少证书而被浏览器报不安全。</li>
<li>Gridea基础配置中的CNAME填入你的域名，不加http或www前缀。<br>
<img src="https://meetbetter.github.io/post-images/1563190931089.png" alt=""><br>
<strong>注意：一定要先在Gridea中基础配置中配置CNAME，否则Gridea同步时调用git上传文章会导致在步骤1中设置的github中CNAME被删除，进而出现下面的域名不可达的问题：</strong><br>
<img src="https://meetbetter.github.io/post-images/1563181533762.png" alt=""></li>
</ol>
<p>现在你就可以在专属域名上浏览自己博客了，更加努力的分享自己写bug的经验吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang protobuf快速上手]]></title>
        <id>https://meetbetter.github.io/post/golang-protobuf-learning</id>
        <link href="https://meetbetter.github.io/post/golang-protobuf-learning">
        </link>
        <updated>2019-03-20T08:08:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="说明">说明</h1>
<p><a href="https://github.com/meetbetter/protocol-buffer-demo">Demo源码</a></p>
<p>protocol buffer是谷歌推出的高效率序列化反序列化工具，可以自定义数据结构，然后使用对应语言的代码生成器生成的代码读写这个数据结构。虽然在和前端打交道时还是要配合使用JSON，但是在其他场合可以尝试使用protocol buffer改进性能。</p>
<p>下面总结下在GoLang中使用protocol buffer的方法。</p>
<h1 id="go环境配置">Go环境配置</h1>
<h2 id="下载protobuf">下载protobuf</h2>
<pre><code class="language-shell">git clone https://github.com/protocolbuffers/protobuf.git
</code></pre>
<h2 id="安装linux-ubuntu">安装(Linux Ubuntu)</h2>
<h3 id="1安装依赖工具">(1)安装依赖工具</h3>
<pre><code class="language-shell">sudo apt-get install autoconf automake libtool curl make g++ unzip libffi-dev -y
</code></pre>
<h3 id="2进入protobuf文件">(2)进入protobuf文件</h3>
<pre><code class="language-shell">cd protobuf/
</code></pre>
<h3 id="3进行安装检测-并生成自动安装脚本">(3)进行安装检测 并生成自动安装脚本</h3>
<pre><code class="language-shell">./autogen.sh
./configure
</code></pre>
<h3 id="4进行编译c代码和安装">(4)进行编译C代码和安装</h3>
<pre><code class="language-shell">make
sudo make install
</code></pre>
<h3 id="5刷新linux共享库关系">(5)刷新linux共享库关系</h3>
<pre><code class="language-shell">sudo ldconfig
</code></pre>
<h3 id="6测试protobuf编译工具">(6)测试protobuf编译工具</h3>
<pre><code class="language-shell">protoc -h
</code></pre>
<p>如果正常输出 相关指令 没有报任何error，为安装成功。</p>
<h2 id="获取-golang的proto包">获取 GoLang的proto包</h2>
<h3 id="1下载">(1)下载</h3>
<pre><code class="language-shell">go get -v -u github.com/golang/protobuf/proto
</code></pre>
<h3 id="2进入到文件夹内进行编译">(2)进入到文件夹内进行编译</h3>
<pre><code class="language-shell">cd $GOPATH/src/github.com/golang/protobuf/protoc-gen-go/
go build
</code></pre>
<h3 id="3拷贝可执行文件">(3)拷贝可执行文件</h3>
<p>将生成的 protoc-gen-go可执行文件，放在/bin目录下。</p>
<pre><code class="language-shell">sudo cp protoc-gen-go /bin/
</code></pre>
<p>尝试补齐protoc-gen-go 如果可以补齐代表成功，如果执行不报错 代表工具成功。</p>
<h1 id="go使用protobuf">Go使用protobuf</h1>
<h2 id="新建proto文件">新建.proto文件</h2>
<p>基本格式如下：</p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;; //必须指定protobuf协议版本号
package pb; //包名

//定义一个protobuf协议
message Person {
    string name = 1; //数字表示序号，并不是变量值.
    int32 age = 2;
    repeated string hobby = 3; //对应go中[]string

}
</code></pre>
<h2 id="生成go数据结构">生成Go数据结构</h2>
<p>在.proto所在目录执行如下命令，</p>
<pre><code class="language-shell">protoc --go_out=.  *.proto
</code></pre>
<p>在当前目录下会生成对应的.go文件，可以在其中找到go的数据结构，</p>
<pre><code class="language-go">type Person struct {
	Name                 string   `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`
	Age                  int32    `protobuf:&quot;varint,2,opt,name=age,proto3&quot; json:&quot;age,omitempty&quot;`
	Hobby                []string `protobuf:&quot;bytes,3,rep,name=hobby,proto3&quot; json:&quot;hobby,omitempty&quot;`
	XXX_NoUnkeyedLiteral struct{} `json:&quot;-&quot;`
	XXX_unrecognized     []byte   `json:&quot;-&quot;`
	XXX_sizecache        int32    `json:&quot;-&quot;`
}
</code></pre>
<p><strong>注意</strong>，该文件只能生成不能手动修改。</p>
<h2 id="使用protobuf">使用protobuf</h2>
<p>在main函数中新建Person对象并进行序列化和反序列化，</p>
<pre><code class="language-go">package main

import (
	&quot;protobufDemo/pb&quot;
	&quot;github.com/golang/protobuf/proto&quot;
	&quot;fmt&quot;
)

func main() {

	//序列化
	person := &amp;pb.Person{
		Name:&quot;Jack&quot;,
		Age:18,
		Hobby:[]string{&quot;sing&quot;,&quot;dance&quot;,&quot;basketball&quot;,&quot;rap&quot;},
	}

	binaryData, err := proto.Marshal(person)
	if err != nil {
		fmt.Println(&quot;proto.Marshal err:&quot;,err)
	}

	//反序列化
	newPerson := &amp;pb.Person{}
	err = proto.Unmarshal(binaryData,newPerson)
	if err != nil {
		fmt.Println(&quot;proto.Unmarshal err:&quot;,err)
	}

	fmt.Println(&quot;序列化前的原始数据:&quot;,person)
	fmt.Println(&quot;反序列化得到数据:&quot;,newPerson)
}

</code></pre>
<p>执行后可以看到person和newPerson都喜欢<strong>唱、跳、篮球和rap</strong>。</p>
<pre><code class="language-shell">序列化前的原始数据: name:&quot;Jack&quot; age:18 hobby:&quot;sing&quot; hobby:&quot;dance&quot; hobby:&quot;basketball&quot; hobby:&quot;rap&quot; 
反序列化得到数据: name:&quot;Jack&quot; age:18 hobby:&quot;sing&quot; hobby:&quot;dance&quot; hobby:&quot;basketball&quot; hobby:&quot;rap&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang调度器介绍和跟踪方法]]></title>
        <id>https://meetbetter.github.io/post/golang-scheduler</id>
        <link href="https://meetbetter.github.io/post/golang-scheduler">
        </link>
        <updated>2019-02-01T07:31:17.000Z</updated>
        <content type="html"><![CDATA[<p>本文记录了本人对Golang调度器的理解和奇怪的goroutine执行顺序，以及跟踪调度器的方法，分享出来一起学习，欢迎交流指正。<br>
<img src="https://i.loli.net/2019/07/31/5d41387a2d73492186.jpg" alt=""></p>
<h1 id="什么是调度器">什么是调度器</h1>
<p>为了方便刚接触操作系统和高级语言的同学，先用大白话介绍下什么是调度器。<br>
调度，是将多个程序合理的安排到有限的CPU上来使得每个程序都能够得以执行，实现宏观的并发执行。比如我们的电脑CPU只有四核甚至双核，可是我们却可以在电脑上同时运行几十个程序，这就是操作系统调度器的功劳。但操作系统调度的是进程和线程，线程简单地说就是轻量级的进程，但是每个线程仍需要MB级别的内存，而且如果两个切换的线程在不同的进程中，还需要进程切换，会使CPU在调度这件事上花费大量时间。<br>
为了更合理的利用CPU，Golang通过goroutine原生支持高并发，goroutine是由go调度器在语言层面进行调度，将goroutine安排到线程上，可以更充分地利用CPU。</p>
<h1 id="golang的调度器">Golang的调度器</h1>
<p>Golang的调度器在runtime中实现，我们每个运行的程序执行前都会运行一个runtime负责调度goroutine，我们写的代码入口要在main包下的main函数中也是因为runtime.main函数会调用main.main。Golang的调度器在2012被重写过一次，现在使用的是新版的G-P-M调度器，但是我们还是先来看下老的G-M调度器，这样才可以更好的体会当前调度器的强大之处。</p>
<h2 id="g-m模型">G-M模型：</h2>
<p>下面是旧调度器的G-P模型：<br>
<img src="https://i.loli.net/2019/07/31/5d4108f2aef5b43754.png" alt=""><br>
M：代表线程，goroutine都是由线程来执行的；<br>
Global G Queue：全局goroutine队列，其中G就代表goroutine，所有M都从这个队列中取出goroutine来执行。<br>
这种模型比较简单，但是问题也很明显：</p>
<ol>
<li>多个M访问一个公共的全局G队列，每次都需要加互斥锁保护，造成激烈的锁竞争和阻塞；</li>
<li>局部性很差，即如果M1上的G1创建了G2，需要将G2交给M2执行，但G1和G2是相关的，最好放在同一个M上执行。</li>
<li>M中有mcache(内存分配状态)，消耗大量内存和较差的局部性。</li>
<li>系统调用syscall会阻塞线程，浪费不能合理的利用CPU。</li>
</ol>
<h2 id="g-p-m模型">G-P-M模型</h2>
<p>后来Go语言开发者改善了调度器为G-P-M模型，如下图：<br>
<img src="https://i.loli.net/2019/07/31/5d4110155291e41796.png" alt=""><br>
其中G还是代表goroutine，M代表线程，全局队列依然存在；而新增加的P代表逻辑processor，现在G的眼中只有P，在G的眼里P就是它的CPU。并且给每个P新增加了局部队列来保存本P要处理的goroutine。<br>
这个模型的调度方法如下;</p>
<ol>
<li>每个P有个局部队列，局部队列保存待执行的goroutine</li>
<li>每个P和一个M绑定，M是真正的执行P中goroutine的实体</li>
<li>正常情况下，M从绑定的P中的局部队列获取G来执行</li>
<li>当M绑定的P的的局部队列已经满了之后就会把goroutine放到全局队列</li>
<li>M是复用的，不需要反复销毁和创建，拥有work stealing和hand off策略保证线程的高效利用。</li>
<li>当M绑定的P的局部队列为空时，M会从其他P的局部队列中偷取G来执行，即work stealing；当其他P偷取不到G时，M会从全局队列获取到本地队列来执行G。</li>
<li>当G因系统调用(syscall)阻塞时会阻塞M，此时P会和M解绑即hand off，并寻找新的idle的M，若没有idle的M就会新建一个M。</li>
<li>当G因channel或者network I/O阻塞时，不会阻塞M，M会寻找其他runnable的G；当阻塞的G恢复后会重新进入runnable进入P队列等待执行</li>
<li>mcache(内存分配状态)位于P，所以G可以跨M调度，不再存在跨M调度局部性差的问题</li>
<li>G是抢占调度。不像操作系统按时间片调度线程那样，Go调度器没有时间片概念，G因阻塞和被抢占而暂停，并且G只能在函数调用时有可能被抢占，极端情况下如果G一直做死循环就会霸占一个P和M，Go调度器也无能为力。</li>
</ol>
<h1 id="go调度器奇怪的坑">Go调度器奇怪的坑</h1>
<p>是不是感觉自己对Go调度器工作原理已经有个初步的了解了？下面指出一个坑给你踩一下，小心了！<br>
请看下面这段代码输出什么：</p>
<pre><code class="language-go">func main() {

	done := make(chan bool)

	values := []string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
	for _, v := range values {
		fmt.Println(&quot;---&gt;&quot;, v)
		go func(u string) {
			fmt.Println(u)
			done &lt;- true
		}(v)
	}

	// wait for all goroutines to complete before exiting
	for _ = range values {
		&lt;-done
	}

}
</code></pre>
<p>先仔细想一下再看答案哦！</p>
<p>实际的数据结果是：</p>
<pre><code class="language-go">---&gt; a
---&gt; b
---&gt; c
c
b
a
</code></pre>
<blockquote>
<p>更多Go调度器示例代码可以在<a href="https://github.com/meetbetter/learn-golang/tree/master/02_advance/09_Go-Schedule">跟着示例代码学golang</a>中查看，持续更新，欢迎star。</p>
</blockquote>
<p>可能你的第一反应是“不应该是输出a,b,c,吗？为什么输出是c,a,b呢？”<br>
这里我们虽然是使用for循环创建了3个goroutine，而且创建顺序是a,b,c，按之前的分析应该是将a,b,c三个goroutine依次放进P的局部队列，然后按照顺序依次执行a,b,c所在的goroutine，为什么每次都是先执行c所在的goroutine呢？这是因为同一逻辑处理器中三个任务被创建后 理论上会按顺序 被放在同一个任务队列，但实际上最后那个任务会被放在专一的next（下一个要被执行的任务的意思）的位置，所以优先级最高，最可能先被执行，所以表现为<strong>在同一个goroutine中创建的多个任务中最后创建那个任务最可能先被执行</strong>。</p>
<blockquote>
<p>这段解释来自参考文章《Goroutine执行顺序讨论》中，原代码未加<code>runtime.GOMAXPROCS(1)</code>限制，可能存在a,b所在goroutine也混乱的情况。</p>
</blockquote>
<h1 id="调度器状态的查看方法">调度器状态的查看方法</h1>
<p>GODEBUG这个Go运行时环境变量很是强大，通过给其传入不同的key1=value1,key2=value2… 组合，Go的runtime会输出不同的调试信息，比如在这里我们给GODEBUG传入了”schedtrace=1000″，其含义就是每1000ms，打印输出一次goroutine scheduler的状态。<br>
下面演示使用Golang强大的GODEBUG环境变量可以查看当前程序中Go调度器的状态：</p>
<blockquote>
<p>环境为Windows10的Linux子系统(WSL)，<a href="https://github.com/meetbetter/learn-golang/blob/master/00_start/02_Windows10-Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85.md">WSL搭建和使用的代码在learn-golang项目有整理</a>，代码在文末参考的鸟窝的文章中也可以找到。</p>
</blockquote>
<pre><code class="language-go">func main() {
   var wg sync.WaitGroup
   wg.Add(10)
   for i := 0; i &lt; 10; i++ {
   	go work(&amp;wg)
   }
   wg.Wait()
   // Wait to see the global run queue deplete.
   time.Sleep(3 * time.Second)
}
func work(wg *sync.WaitGroup) {

   time.Sleep(time.Second)
   var counter int
   for i := 0; i &lt; 1e10; i++ {
   	counter++
   }
   wg.Done()
}
</code></pre>
<p>编译指令：</p>
<pre><code class="language-shell">go build 01_GODEBUG-schedtrace.go
GODEBUG=schedtrace=1000 ./01_GODEBUG-schedtrace
</code></pre>
<p>结果：</p>
<pre><code class="language-shell">SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=5 spinningthreads=1 idlethreads=0 runqueue=0 [4 0 4 0]
SCHED 1000ms: gomaxprocs=4 idleprocs=4 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 2007ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 3025ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 4033ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 5048ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 6079ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 7081ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 8092ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 6]
SCHED 9113ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 10129ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 11134ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 12157ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 13170ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 14183ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 15187ms: gomaxprocs=4 idleprocs=0 threads=8 spinningthreads=0 idlethreads=3 runqueue=0 [0 1 0 1]
SCHED 16187ms: gomaxprocs=4 idleprocs=2 threads=8 spinningthreads=0 idlethreads=5 runqueue=0 [0 0 0 0]
SCHED 17190ms: gomaxprocs=4 idleprocs=2 threads=8 spinningthreads=0 idlethreads=5 runqueue=0 [0 0 0 0]
SCHED 18193ms: gomaxprocs=4 idleprocs=2 threads=8 spinningthreads=0 idlethreads=5 runqueue=0 [0 0 0 0]
SCHED 19196ms: gomaxprocs=4 idleprocs=2 threads=8 spinningthreads=0 idlethreads=5 runqueue=0 [0 0 0 0]
SCHED 20200ms: gomaxprocs=4 idleprocs=4 threads=8 spinningthreads=0 idlethreads=6 runqueue=0 [0 0 0 0]
SCHED 21210ms: gomaxprocs=4 idleprocs=4 threads=8 spinningthreads=0 idlethreads=6 runqueue=0 [0 0 0 0]
SCHED 22219ms: gomaxprocs=4 idleprocs=4 threads=8 spinningthreads=0 idlethreads=6 runqueue=0 [0 0 0 0]
</code></pre>
<p>看到怎么多输出不要慌， 了解每个字段的含义就很清晰了：</p>
<ul>
<li>SCHED 1000ms<br>
自程序运行开始经历的时间</li>
<li>gomaxprocs=4<br>
当前程序使用的逻辑processor，即P，小于等于CPU的核数。</li>
<li>idleprocs=4<br>
空闲的线程数</li>
<li>threads=8<br>
当前程序的总线程数M，包括在执行G的和空闲的</li>
<li>spinningthreads=0<br>
处于<strong>自旋</strong>状态的线程，即M在绑定的P的局部队列和全局队列都没有G，M没有销毁而是在四处寻觅有没有可以steal的G，这样可以减少线程的大量创建。</li>
<li>idlethreads=3<br>
处于idle空闲状态的线程</li>
<li>runqueue=0<br>
全局队列中G的数目</li>
<li>[0 0 0 6]<br>
本地队列中的每个P的局部队列中G的数目，我的电脑是四核所有有四个P。</li>
</ul>
<p>上面的输出信息已经足够我们了解我们的程序运行状况，要想看每个goroutine、m和p的详细调度信息，可以在GODEBUG时加入，<code>scheddetail</code>：</p>
<pre><code class="language-shell">GODEBUG=schedtrace=1000,scheddetail=1 ./01_GODEBUG-schedtrace
</code></pre>
<p>结果如下：</p>
<pre><code class="language-shell">SCHED 0ms: gomaxprocs=4 idleprocs=4 threads=7 spinningthreads=0 idlethreads=2 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0
 P0: status=0 schedtick=7 syscalltick=1 m=-1 runqsize=0 gfreecnt=0
 P1: status=0 schedtick=2 syscalltick=1 m=-1 runqsize=0 gfreecnt=0
 P2: status=0 schedtick=1 syscalltick=1 m=-1 runqsize=0 gfreecnt=0
 P3: status=0 schedtick=1 syscalltick=1 m=-1 runqsize=0 gfreecnt=0
 M6: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 M5: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 M4: p=-1 curg=33 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 M3: p=-1 curg=49 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 M2: p=-1 curg=17 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 M1: p=-1 curg=-1 mallocing=0 throwing=0 preemptoff= locks=1 dying=0 spinning=false blocked=false lockedg=-1
 M0: p=-1 curg=14 mallocing=0 throwing=0 preemptoff= locks=0 dying=0 spinning=false blocked=true lockedg=-1
 G1: status=4(semacquire) m=-1 lockedm=-1
 G2: status=4(force gc (idle)) m=-1 lockedm=-1
 G3: status=4(GC sweep wait) m=-1 lockedm=-1
 G4: status=4(sleep) m=-1 lockedm=-1
 G5: status=4(sleep) m=-1 lockedm=-1
 G6: status=4(sleep) m=-1 lockedm=-1
 G7: status=4(sleep) m=-1 lockedm=-1
 G8: status=4(sleep) m=-1 lockedm=-1
 G9: status=4(sleep) m=-1 lockedm=-1
 G10: status=4(sleep) m=-1 lockedm=-1
 G11: status=4(sleep) m=-1 lockedm=-1
 G12: status=4(sleep) m=-1 lockedm=-1
 G13: status=4(sleep) m=-1 lockedm=-1
 G14: status=3() m=0 lockedm=-1
 G33: status=3() m=4 lockedm=-1
 G17: status=3() m=2 lockedm=-1
 G49: status=3() m=3 lockedm=-1
</code></pre>
<p>参考资料：<br>
<a href="https://mp.weixin.qq.com/s?__biz=Mzg3MTA0NDQ1OQ==&amp;mid=2247483869&amp;idx=1&amp;sn=bf6f038dbe6c7bde5954fc37c0e449b5&amp;scene=21#wechat_redirect">大彬Go调度器系列</a><br>
<a href="https://tonybai.com/2017/06/23/an-intro-about-goroutine-scheduler/">也谈goroutine调度器</a><br>
<a href="https://colobu.com/2016/04/19/Scheduler-Tracing-In-Go/">鸟窝 Go调度器跟踪</a><br>
<a href="https://zhuanlan.zhihu.com/p/27056944">Go调度器详解</a><br>
<a href="https://gocn.vip/question/1117">Goroutine执行顺序讨论</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang GC全解析]]></title>
        <id>https://meetbetter.github.io/post/golang-GC-1</id>
        <link href="https://meetbetter.github.io/post/golang-GC-1">
        </link>
        <updated>2018-12-30T15:28:38.000Z</updated>
        <content type="html"><![CDATA[<p>本文主要介绍了垃圾回收的概念，Golang GC的垃圾回收算法和工作原理，看完本文可以让你对Golang垃圾回收机制有个全面的理解。由于本人不了解其他语言的GC，并未对比其他语言的垃圾回收算法，需要的可以自行Google。</p>
<h1 id="什么是垃圾回收">什么是垃圾回收</h1>
<p>垃圾回收（英语：Garbage Collection，缩写为GC），在计算机科学中是一种自动的存储器管理机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为垃圾回收。垃圾回收器可以让程序员减轻许多负担，也减少程序员犯错的机会。来自<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">维基百科</a></p>
<p>简单地说，<strong>垃圾回收(GC)是在后台运行一个守护线程，它的作用是在监控各个对象的状态，识别并且丢弃不再使用的对象来释放和重用资源。</strong></p>
<h1 id="go的垃圾回收">go的垃圾回收</h1>
<p>当前Golang使用的垃圾回收机制是<strong>三色标记发</strong>配合<strong>写屏障</strong>和<strong>辅助GC</strong>，三色标记法是<strong>标记-清除法</strong>的一种增强版本。</p>
<h2 id="标记-清除法mark-and-sweep">标记-清除法（mark and sweep）</h2>
<p>原始的标记清楚法分为两个步骤：</p>
<ol>
<li>标记。先STP(Stop The World)，暂停整个程序的全部运行线程，将被引用的对象打上标记</li>
<li>清除没有被打标机的对象，即回收内存资源，然后恢复运行线程。<br>
这样做有个很大的问题就是要通过STW保证GC期间标记对象的状态不能变化，整个程序都要暂停掉，在外部看来程序旧很卡。</li>
</ol>
<h2 id="三色标记法">三色标记法</h2>
<p>三色标记法是对标记阶段的改进，原理如下：</p>
<ol>
<li>初始状态所有对象都是白色。</li>
<li>从root根出发扫描所有根对象（下图a,b），将他们引用的对象标记为灰色（图中A，B）</li>
</ol>
<blockquote>
<p>那么什么是root呢？<br>
看了很多文章都没解释这这个概念，在这儿说明下：root区域主要是程序运行到当前时刻的栈和全局数据区域。</p>
</blockquote>
<p><img src="https://meetbetter.github.io/post-images/1564319758848.png" alt=""><br>
3.  分析灰色对象是否引用了其他对象。如果没有引用其它对象则将该灰色对象标记为黑色（图中A）；如果有引用则将它变为黑色的同时将它引用的对象也变为灰色（图中B引用了D）<br>
4. 重复步骤3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。<br>
也可以参考下面的动图辅助理解：<br>
<img src="https://meetbetter.github.io/post-images/1563296640046.gif" alt=""></p>
<h2 id="go-gc如何工作">GO GC如何工作</h2>
<p>上面介绍的是GO GC采用的三色标记算法，但是好像并没有体现出来怎么减少STW对程序的影响呢？其实是因为<strong>Golang GC的大部分处理是和用户代码并行的</strong>。</p>
<p>GC期间用户代码可能会改变某些对象的状态，如何实现GC和用户代码并行呢？先看下GC工作的完整流程：</p>
<ol>
<li>Mark: 包含两部分:</li>
</ol>
<ul>
<li>Mark Prepare: 初始化GC任务，包括开启写屏障(write barrier)和辅助GC(mutator assist)，统计root对象的任务数量等。<strong>这个过程需要STW</strong></li>
<li>GC Drains: 扫描所有root对象，包括全局指针和goroutine(G)栈上的指针（扫描对应G栈时需停止该G)，将其加入标记队列(灰色队列)，并循环处理灰色队列的对象，直到灰色队列为空。<strong>该过程后台并行执行</strong></li>
</ul>
<ol start="2">
<li>Mark Termination: 完成标记工作，重新扫描(re-scan)全局指针和栈。因为Mark和用户程序是并行的，所以在Mark过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障（write barrier）记录下来，re-scan 再检查一下。<strong>这个过程也是会STW的。</strong></li>
<li>Sweep: 按照标记结果回收所有的白色对象，<strong>该过程后台并行执行</strong></li>
<li>Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC。<br>
如果标记期间用户逻辑改变了刚打完标记的对象的引用状态，怎么办呢？</li>
</ol>
<h2 id="写屏障write-barrier">写屏障(Write Barrier)</h2>
<p>写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。<br>
好难懂哦，结合上面GC工作的完整流程就好理解了，就是在每一轮GC开始时会初始化一个叫做“屏障”的东西，然后由它记录第一次scan时各个对象的状态，以便和第二次re-scan进行比对，引用状态变化的对象被标记为灰色以防止丢失，将屏障前后状态未变化对象继续处理。</p>
<h2 id="辅助gc">辅助GC</h2>
<p>从上面的GC工作的完整流程可以看出Golang GC实际上把单次暂停时间分散掉了，本来程序执⾏可能是“⽤户代码--&gt;⼤段GC--&gt;⽤户代码”，那么分散以后实际上变成了“⽤户代码--&gt;⼩段 GC--&gt;⽤户代码--&gt;⼩段GC--&gt;⽤户代码”这样。如果GC回收的速度跟不上用户代码分配对象的速度呢？<br>
Go 语⾔如果发现扫描后回收的速度跟不上分配的速度它依然会把⽤户逻辑暂停，⽤户逻辑暂停了以后也就意味着不会有新的对象出现，同时会把⽤户线程抢过来加⼊到垃圾回收⾥⾯加快垃圾回收的速度。这样⼀来原来的并发还是变成了STW，还是得把⽤户线程暂停掉，要不然扫描和回收没完没了了停不下来，因为新分配对象⽐回收快，所以这种东⻄叫做辅助回收。</p>
<h2 id="如何进行gc调优">如何进行GC调优</h2>
<p>衡量GC对程序的影响可以参考这篇文章，<a href="https://www.oschina.net/translate/debugging-performance-issues-in-go-programs">Go 程序的性能调试问题</a>。<br>
减少GC对象分配；<br>
避免string与[]byte转化；<br>
少量使用+连接 string；</p>
<h2 id="gc触发条件">GC触发条件</h2>
<p>自动垃圾回收的触发条件有两个：</p>
<ol>
<li>超过内存大小阈值</li>
<li>达到定时时间<br>
阈值是由一个gcpercent的变量控制的,当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。<br>
如果一直达不到内存大小的阈值呢？这个时候GC就会被定时时间触发，比如一直达不到10M，那就定时（默认2min触发一次）触发一次GC保证资源的回收。</li>
</ol>
<h1 id="写在最后">写在最后</h1>
<p>虽然Golang有自动垃圾回收机制，但是GC不是万能的，最好还是养成手动回收内存的习惯：比如在程序中调用runtime.GC()，也可以手动把不适用的对象置成nil。</p>
<p>参考：<br>
<a href="https://www.jianshu.com/p/8b0c0f7772da">Go语言——垃圾回收GC</a><br>
<a href="https://mp.weixin.qq.com/s/Wh7A6czDIRofxveY_bEDNQ">Golang 垃圾回收剖析</a><br>
<a href="https://blog.csdn.net/u010649766/article/details/80582153">Golang垃圾回收机制详解</a><br>
<a href="https://lihaoquan.me/2016/11/3/go-gc-general.html">go垃圾回收概要</a><br>
<a href="https://wudaijun.com/2017/12/gc-study/">常见GC算法及Golang GC</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go“一个包含nil指针的接口不是nil接口”踩坑]]></title>
        <id>https://meetbetter.github.io/post/go-interface-nil</id>
        <link href="https://meetbetter.github.io/post/go-interface-nil">
        </link>
        <updated>2018-11-03T12:53:59.000Z</updated>
        <content type="html"><![CDATA[<p>最近在项目中踩了一个深坑——“Golang中一个包含nil指针的接口不是nil接口”，总结下分享出来，如果你不是很理解这句话，那推荐认真看下下面的示例代码，避免以后写代码时踩坑。</p>
<h1 id="示例一">示例一</h1>
<p>先一起来看下这段代码，你感觉有没有问题呢？</p>
<pre><code class="language-go">type IPeople interface {
	hello()
}
type People struct {
}

func (p *People) hello() {
	fmt.Println(&quot;github.com/meetbetter&quot;)
}

func errFunc1(in int) *People {
	if in == 0 {
		fmt.Println(&quot;importantFunc返回了一个nil&quot;)
		return nil
	} else {
		fmt.Println(&quot;importantFunc返回了一个非nil值&quot;)
		return &amp;People{}
	}

}

func main() {
	var i IPeople

	in := 0

	i = errFunc1(in)

	if i == nil {

		fmt.Println(&quot;哈，外部接收到也是nil&quot;)
	} else {

		fmt.Println(&quot;咦，外部接收到不是nil哦&quot;)
		fmt.Printf(&quot;%v, %T\n&quot;, i, i)
	}

}
</code></pre>
<p>这段代码的执行结果是:</p>
<pre><code class="language-shell">importantFunc返回了一个nil
咦，外部接收到不是nil哦
&lt;nil&gt;, *main.People
</code></pre>
<p>可以看到在main函数中收到的返回值不是nil， 明明在errFunc1()函数中返回的是nil，到了main函数为什么收到的不是nil呢？<br>
这是因为：将nil赋值给<code>*People</code>后再将<code>*People</code>赋值给interface，<code>*People</code>本身是是个指向nil的指针，但是将其赋给接口时只是接口中的值为nil，但是接口中的类型信息为<code>*main.People</code>而不是nil，所以这个接口不是nil。<br>
是的，Golang中的interface类型包含两部分信息——值信息和类型信息，只有interface的值合并类型都为nil时interface才为nil，interface底层实现可以在后面的源码分析看到。</p>
<p>先来看看正确的处理接口返回值的方法，是直接将nil赋给interface：</p>
<pre><code class="language-go">
func rightFunc(in int) IPeople {
	if in == 0 {
		fmt.Println(&quot;importantFunc返回了一个nil&quot;)
		return nil
	} else {
		fmt.Println(&quot;importantFunc返回了一个非nil值&quot;)
		return &amp;People{}
	}

}
</code></pre>
<h1 id="示例二">示例二</h1>
<p>下面的代码更清晰的证明了<code>一个包含nil指针的接口不是nil接口</code>的结论：</p>
<pre><code class="language-go">type IPeople interface {
	hello()
}
type People struct {
}

func (p *People) hello() {
	fmt.Println(&quot;github.com/meetbetter&quot;)
}

//错误：将nil的people给空接口后接口就不为nil,因为interface中的value为nil但type不为nil
func errFunc() *People {
	var p *People

	return p
}

//正确处理返回nil给接口的方式：直接将nil赋给interface
func rightFunc() IPeople {
	var p *People

	return p
}
func main() {

	if errFunc() == nil {

		fmt.Println(&quot;对了哦，外部接收到也是nil&quot;)
	} else {

		fmt.Println(&quot;错了咦，外部接收到不是nil哦&quot;)

	}

	if rightFunc() == nil {

		fmt.Println(&quot;对了哦，外部接收到也是nil&quot;)
	} else {

		fmt.Println(&quot;错了咦，外部接收到不是nil哦&quot;)

	}

}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">对了哦，外部接收到也是nil
错了咦，外部接收到不是nil哦
</code></pre>
<h1 id="interface底层实现">interface底层实现</h1>
<p>下面的注释信息来自参考文章中，从interface底层实现可以看出iface比eface 中间多了一层itab结构， itab 存储_type信息和[]fun方法集，所以即使data指向了nil 并不代表interface 就是nil， 还要考虑_type信息。</p>
<pre><code class="language-go">type eface struct {      //空接口
    _type *_type         //类型信息
    data  unsafe.Pointer //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)
}
type iface struct {      //带有方法的接口
    tab  *itab           //存储type信息还有结构实现方法的集合
    data unsafe.Pointer  //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void*)
}
type _type struct {
    size       uintptr  //类型大小
    ptrdata    uintptr  //前缀持有所有指针的内存大小
    hash       uint32   //数据hash值
    tflag      tflag
    align      uint8    //对齐
    fieldalign uint8    //嵌入结构体时的对齐
    kind       uint8    //kind 有些枚举值kind等于0是无效的
    alg        *typeAlg //函数指针数组，类型实现的所有方法
    gcdata    *byte
    str       nameOff
    ptrToThis typeOff
}
type itab struct {
    inter  *interfacetype  //接口类型
    _type  *_type          //结构类型
    link   *itab
    bad    int32
    inhash int32
    fun    [1]uintptr      //可变大小 方法集合
}
</code></pre>
<p>以上完整代码均整理在<a href="https://github.com/meetbetter/learn-golang/tree/master/02_advance/11_nil-interface">Github-跟着示例代码学Golang项目</a>。</p>
<p>参考文章：<br>
<a href="https://studygolang.com/articles/10635">Golang第一大坑</a></p>
<p><a href="https://gocn.vip/question/1011">&quot;一个包含nil指针的接口不是nil接口&quot;的讨论</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解Golang channel]]></title>
        <id>https://meetbetter.github.io/post/go-channel</id>
        <link href="https://meetbetter.github.io/post/go-channel">
        </link>
        <updated>2018-10-02T11:16:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="channel是什么">channel是什么</h1>
<p>channel中文翻译成“管道”，很形象地体现出了channel的基本用途——传输数据的通道。<br>
channel的作用可以分为两个：</p>
<ol>
<li>在goroutine之间传输数据</li>
<li>同步，即goroutine调度<br>
channel是Golang CSP(Communicating Sequential Processes)的核心，即gopher常说的“通过通信来共享内存，而不是通过共享内存而通信”。</li>
</ol>
<h1 id="channel的类型">channel的类型</h1>
<p>channel按缓冲区可分为：</p>
<ol>
<li>无缓冲channel</li>
</ol>
<pre><code class="language-go">ch := make(chan int)
</code></pre>
<p>同步模式，channel的读写端必须同时在线，否则会阻塞。<br>
2. 有缓冲channel</p>
<pre><code class="language-go">ch := make(chan int, 100)
</code></pre>
<p>即异步模式，读写两端不必同时在线，在缓冲区满之前写端不会阻塞，在缓冲区数据被读完之前读端不会阻塞。</p>
<p>按数据流向可分为：</p>
<ol>
<li>双向channel，可读可写</li>
<li>只读channel</li>
<li>只写channel</li>
</ol>
<pre><code class="language-go">chan T //可以接收发送类型为T的双向channel
chan&lt;- T //只可以发送类型为T的只写channel
&lt;-chan T //只可以接收类型为T的只读channel
</code></pre>
<h1 id="channel的特性">channel的特性</h1>
<ul>
<li>往nil channel写数据会一直阻塞；</li>
<li>从nil channel读数据会一直阻塞；</li>
<li>往已经close的channel写数据会导致panic</li>
<li>从已经close的channel读数据会读到对应类型的零值</li>
<li>close一个已经close过的channel会导致panic。</li>
</ul>
<h1 id="channel应用">channel应用</h1>
<h2 id="同步">同步</h2>
<pre><code class="language-go">
package main

/*
	演示channel的同步作用
*/

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func send(done, quit chan bool) {
	//等待recv完成后由send关闭
	&lt;-done
	fmt.Println(&quot;那我关闭了哦&quot;)

	//通知main goroutine
	quit &lt;- true
}

func recv(done chan bool) {
	time.Sleep(time.Second)
	// 通知任务已完成
	fmt.Println(&quot;对面的send可以关闭了&quot;)
	done &lt;- true
}

func main() {
	done := make(chan bool)
	quit := make(chan bool)
	go send(done, quit)
	go recv(done)
	// 等待任务完成
	&lt;-quit
	fmt.Println(&quot;main也结束了哦&quot;)
}

</code></pre>
<h2 id="select读取多个channel">select读取多个channel</h2>
<p>select可以监听多个case上的IO流动，配合channel可以实现监听多个channel的数据：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func fibonacci(data, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case data &lt;- x:
			x, y = y, x+y
		case &lt;-quit:
			fmt.Println(&quot;quit&quot;)
			return
		}
	}
}
func main() {
	data := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i &lt; 20; i++ {
			fmt.Println(&lt;-data)
		}
		quit &lt;- 0
	}()
	fibonacci(data, quit)
}

</code></pre>
<h2 id="channel超时">channel超时</h2>
<p>channel超时未收到数据则关闭：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;
)

func selectFunc(data &lt;-chan string, quit chan bool) {

	for {

		select {
		case res := &lt;-data:
			fmt.Println(res)
		case &lt;-time.After(time.Second * 2): //其它case有数据时，select结束, time被重置
			fmt.Println(&quot;timeout ,will quit&quot;)
			&lt;-quit
		}
	}

}
func main() {
	data := make(chan string, 1)
	quit := make(chan bool)
	go selectFunc(data, quit)

	for i := 0; i &lt; 5; i++ {
		time.Sleep(time.Second)
		data &lt;- &quot;github.com/meetbetter&quot;
	}

	quit &lt;- true

}
</code></pre>
<h2 id="channel的关闭">channel的关闭</h2>
<p>当channel已经关闭之后，写端再往里写数据会导致panic，但是读端仍可以读，如果是无缓冲buffer，读端会读到对应类型的零值；如果是有缓冲buffer，写端关闭后读端仍可以读取数据，直到把数据读完才会读到零值。<br>
因为往已经close的channel中写数据会panic，所以最好由写端关闭channel，读端判断channel是否已关闭。那如何判断对端已关闭呢？<br>
可以使用返回值&quot;ok&quot;判断，如果写端已关闭channel，返回值&quot;ok&quot;会为false：</p>
<pre><code class="language-go">  if data, ok := &lt;-ch1; ok {
                fmt.Println(data)
            }
</code></pre>
<p>也可以使用range遍历，当写端关闭channel时，range会跳出循环：</p>
<pre><code class="language-go">  for data := range  ch1{
            fmt.Println(data)
        }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang map底层实现]]></title>
        <id>https://meetbetter.github.io/post/go-map</id>
        <link href="https://meetbetter.github.io/post/go-map">
        </link>
        <updated>2018-09-30T13:46:28.000Z</updated>
        <content type="html"><![CDATA[<p>首先否定两个错误说法：“map高效率是因为map是链式结构存储”，“map的无序是因为map是散列表”。这是之前听到的说法，后来深入学习了golang map的底层实现后，发现这些说法是很错误的，现在将自己学习map的心得整理出来，欢迎指正。</p>
<h1 id="map的底层实现">map的底层实现</h1>
<p>粗略的讲，Go语言中map采用的是哈希查找表，由一个key通过哈希函数得到哈希值，64位系统中就生成一个64bit的哈希值，由这个哈希值将key对应到不同的桶（bucket）中，当有多个哈希映射到相同的的桶中时，使用链表解决哈希冲突。<br>
详细的说，就涉及到map的数据结构哈希函数，hmap，bmap。</p>
<h2 id="hash函数">hash函数</h2>
<p>首先要知道的就是map中哈希函数的作用，go中map使用hash作查找，就是将key作哈希运算，得到一个哈希值，根据哈希值确定key-value落在哪个bucket的哪个cell。golang使用的hash算法和CPU有关，如果cpu支持aes，那么使用aes hash，否则使用memhash。</p>
<h2 id="map的数据结构">map的数据结构</h2>
<h3 id="hmap">hmap</h3>
<p>hmap可以理解为 header of map的缩写，即map数据结构的入口。<br>
map的数据结构定义在<code>runtime/map.go/hmap</code>中，以下注释来自<a href="https://github.com/cch123/golang-notes/blob/master/map.md">曹大Github map源码分析</a>，我修改了部分注释使之更直白：</p>
<pre><code class="language-go">// header of map
type hmap struct {
    count     int // map 中的元素个数，必须放在 struct 的第一个位置，因为 内置的 len 函数会从这里读取
    flags     uint8 //map状态标识，比如是否在被写或者迁移等，因为map不是线程安全的所以操作时需要判断flags
    B         uint8  // log_2 of # of buckets (最多可以放 loadFactor * 2^B 个元素即6.5*2^B，再多就要 hashGrow 了)
    noverflow uint16 // overflow 的 bucket 的近似数
    hash0     uint32 // hash seed，随机哈希种子可以防止哈希碰撞攻击

    buckets    unsafe.Pointer // 存储数据的buckets数组的指针， 大小2^B，如果 count == 0 的话，可能是 nil
    oldbuckets unsafe.Pointer // 一半大小的之前的 bucket 数组，只有在 growing 过程中是非 nil
    nevacuate  uintptr        // 扩容进度标志，小于此地址的buckets已迁移完成。

    extra *mapextra // 可以减少GC扫描，当 key 和 value 都可以 inline 的时候，就会用这个字段
}
</code></pre>
<p>根据注释可以看出各个字段的作用，需要重点说明的是最后一个字段<code>extra *mapextra</code>，针对key和value都不是指针类型的map，并且大小都小于128字节，则使用mapextra来存储，这样可以避免GC扫描整个map。</p>
<pre><code class="language-go">type mapextra struct {
    // 如果 key 和 value 都不包含指针，并且可以被 inline(&lt;=128 字节)
    // 使用 extra 来存储 overflow bucket，这样可以避免 GC 扫描整个 map
    // 然而 bmap.overflow 也是个指针。这时候我们只能把这些 overflow 的指针
    // 都放在 hmap.extra.overflow 和 hmap.extra.oldoverflow 中了
    // overflow 包含的是 hmap.buckets 的 overflow 的 bucket
    // oldoverflow 包含扩容时的 hmap.oldbuckets 的 overflow 的 bucket
    overflow    *[]*bmap
    oldoverflow *[]*bmap

    // 指向空闲的 overflow bucket 的指针
    nextOverflow *bmap
}
</code></pre>
<h3 id="bmap">bmap</h3>
<p>bmap可以理解为buckets of map的缩写，她就是map中bucket的本体，即存key和value数据的“桶”。</p>
<pre><code class="language-go">type bmap struct {
    // tophash 是 hash 值的高 8 位
    tophash [bucketCnt]uint8
		//以下字段没有显示定义在bmap，但是编译时编译器会自动添加
    // keys //每个桶最多可以装8个key
    // values //8个key分别有8个value一一对应
    // overflow pointer  //发生哈希碰撞之后创建的overflow bucket
}
</code></pre>
<p>根据哈希函数将key生成一个哈希值，其中低位哈希用来判断桶位置，高位哈希用来确定在桶中哪个cell。<strong>低位哈希</strong>就是哈希值的低B位，hmap结构体中的B，比如B为5，2^5=32，即该map有32个桶，只需要取哈希值的低5位就可以确定当前key-value落在哪个桶(bucket)中；<strong>高位哈希</strong>即tophash，是指哈希值的高8bits，根据tophash来确定key在桶中的位置。每个桶可以存储8对key-value，存储结构不是key/value/key/value...，而是key/key..value/value，这样可以避免字节对时的padding，节省内存空间。</p>
<p>仔细想一下，当不同的key根据哈希得到的tophash和低位hash都一样岂不是会覆盖原来的key-value数据？这种情况有个专业名词叫“哈希碰撞”，这个时候就体现<code>overflow pointer</code>字段的作用了。当某一个key根据自己的哈希值找到对应的bucket和key位置时，发现这个位置已经名花有主，即桶溢出了，就需要存储在overflow bucket（溢出桶），overflow pointer就是指向overflow bucket的指针。如果overflow bucket也溢出了呢？那就再给overflow bucket新建一个overflow bucket，用指针串起来就形成了链式结构，所以开头所说的“map是链式存储并不准确”，map本身有2^B个bucket，只有当发生哈希碰撞后才会在bucket后链式增加overflow bucket。</p>
<h2 id="map内存布局">map内存布局</h2>
<p>通过上面我们可以想象map在内存中的布局情况：<br>
一个map对应着多个buckets，每个bucket后面又因为哈希碰撞而存在数量不定的overflow bucket。<br>
<img src="https://meetbetter.github.io/post-images/1564210141673.png" alt=""></p>
<h2 id="扩容">扩容</h2>
<p>再仔细想一下，如果overflow bucket一直链式增加，但是并不是每个bucket的8个cell都是满的，那map的高效率还能保证吗？<br>
这就需要用到map的扩容机制了，当向map插入数据时，会判断是否满足以下两个条件之一：</p>
<ol>
<li>装载因子是否大于6.5</li>
</ol>
<blockquote>
<p>装载因子 = 元素个数/桶个数，大于6.5时说明大部分桶已经要装满，需要扩容。</p>
</blockquote>
<ol start="2">
<li>overflow bucket是否太多。</li>
</ol>
<blockquote>
<p>当 bucket数量 &lt; 2^15时，如果overflow bucket数量大于bucket数量，则说明overflow bucket数量太多了；<br>
当bucket数量 &gt;= 2^15时，如果overflow bucket数量大于2^15，则说明overflow bucket数量太多了；<br>
overflow bucket桶太多说明有很多cell空闲，查找效率就会变低。曹大文章里说导致这种情况的原因是map一遍插入一边删除，但map不是线程安全的，一遍插入一边删除会导致panic，所以我的理解不是同时插入，而是先往map中插入了大量哈希值高低位相同的key，导致overflow bucket数量很多，再删除一些数据，这时装载因子并未大于6.5，但却有大量的overflow bucket，这就造成很多bucke的cell空着，却有大量的overflow bucket，从而降低查询效率。</p>
</blockquote>
<p>两种触发条件的适用的场景不一致，扩容方法也不一致。针对第一种装载因子过大的情况，只需要bucket数量增加一倍，即B+1，这称为“双倍扩容”。针对第二种overflow太多的情况，使用的方法是重新排列键值对使之排列更紧密，减少overflow bucket，bucket总数未改变，这称为“等量扩容”。</p>
<blockquote>
<p>但是在极端情况下，比如插入了大量的哈希值高低位相同的key，第二种方法也无能为力，为了解决哈希碰撞不得不使用overflow bucket，此时map变成了链式存储，查询和插入效率就会变低，hmap中的hash0字段是makemap时的rand seed，可以降低这种极端情况的发生 。</p>
</blockquote>
<p>在第一种情况下，B+1之后，根据key的哈希值低B位查找落在哪个桶也需要加一，即向前多取一位哈希值来当作新的低哈希，所以数据搬移后原来的key可能落在其他桶中，取决于向前取的这一位是0还是1。<br>
另外，map的扩容是渐进式的扩容，并不是一次性将原bucket的数据搬移到新的地址，这样未免太占用CPU了，而是在每一次访问旧buckets时就搬移一部分，直到全部搬移完成，旧的buckets被GC回收。</p>
<h2 id="查找过程">查找过程</h2>
<p>通过上面的介绍可以直到map的查找过程：</p>
<ol>
<li>根据key计算出哈希值</li>
<li>根据哈希值低位确定所在bucket</li>
<li>根据哈希值高8位确定在bucket中的存储位置</li>
<li>当前bucket未找到则查找对应的overflow bucket。</li>
<li>对应位置有数据则对比完整的哈希值，确定是否是要查找的数据</li>
<li>如果当前处于map进行了扩容，处于数据搬移状态，则优先从oldbuckets查找。</li>
</ol>
<p>先用哈希值高低位确定位置再对比完整哈希值的方法提高了查找效率。<br>
另外要注意：查找不到也不会返回空值，而是返回对应数据类型的零值，所以我们判断map中某个key是否存在时要接收两个返回值，如 <code>data,ok := m[&quot;hahaha&quot;]</code>，第二个返回值为bool类型，标识查询的数据是否存在。</p>
<h2 id="插入过程">插入过程</h2>
<p>删除map数据的过程是先查找再删除：</p>
<ol>
<li>根据key计算出哈希值</li>
<li>根据哈希值低位确定所在bucket</li>
<li>根据哈希值高8位确定在bucket中的存储位置</li>
<li>查找该key是否存在，已存在则更新，不存在则插入</li>
</ol>
<h1 id="map无序的原因">map无序的原因</h1>
<p>看完上面的内容，可以理解“map高效率是因为map是链式结构存储”是错误的说法了吧，那为什么“map的无序是因为map是散列表”也是错误的呢？之前在网上看到说因为map是哈希的，所以遍历出来是无序的。其实map无序和哈希无关，而是<strong>Go map遍历出的结果是随机的是因为Go设计者故意这样做的</strong>。<br>
分析如下：<br>
通过上面的学习已经知道，map的本质是散列表，而map的增长扩容会导致重新进行散列，这就可能使map的遍历结果在扩容前后变得不可靠，Go设计者为了让大家不依赖遍历的顺序，故意在实现map遍历时加入了随机数，让每次遍历的起点--即起始bucket的位置--不一样，即不让遍历都从bucket0开始，所以即使未扩容时我们遍历出来的map也总是无序的(<em><sup>_</sup></em>)。<br>
看一下runtime.mapiterinit源码：</p>
<pre><code class="language-go">func mapiterinit(t *maptype, h *hmap, it *hiter) {
    ...
    it.t = t
    it.h = h
    it.B = h.B
    it.buckets = h.buckets
    if t.bucket.kind&amp;kindNoPointers != 0 {
        h.createOverflow()
        it.overflow = h.extra.overflow
        it.oldoverflow = h.extra.oldoverflow
    }

    r := uintptr(fastrand())
    if h.B &gt; 31-bucketCntBits {
        r += uintptr(fastrand()) &lt;&lt; 31
    }
    it.startBucket = r &amp; bucketMask(h.B)
    it.offset = uint8(r &gt;&gt; h.B &amp; (bucketCnt - 1))
    it.bucket = it.startBucket
    ...

    mapiternext(it)
}
</code></pre>
<p>这个函数是map遍历前的初始化操作，注意看<code>fastrand())</code>，根据名字也可以猜出它的作用了吧，就是<code>fastrand())</code>生成随机数让每次遍历的起始位置不停变化。<br>
个人猜测不同CPU下哈希函数的选择可能不同也是促使go设计者这样做的原因之一。</p>
<h2 id="让map变有序的方法">让map变有序的方法</h2>
<p>如果想让map遍历结果变得有序，可以自己对map的key进行依次排序，实现如下：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sort&quot;
)

func main() {
	m := make(map[string]string)
	m[&quot;111&quot;] = &quot;1111&quot;
	m[&quot;222&quot;] = &quot;2222&quot;
	m[&quot;333&quot;] = &quot;3333&quot;
	m[&quot;444&quot;] = &quot;4444&quot;
	m[&quot;555&quot;] = &quot;5555&quot;

	sorted_keys := make([]string, 0)
	for k, _ := range m {
		sorted_keys = append(sorted_keys, k)
	}

	// sort 'string' key in increasing order
	sort.Strings(sorted_keys)

	for _, k := range sorted_keys {
		fmt.Printf(&quot;k=%v, v=%v\n&quot;, k, m[k])
	}
}
</code></pre>
<p>至此相信你对Golang map的底层实现有个大概认知了吧，最后再说一句，go中只有值传递，map和channel可以在函数内影响函数外是因为他们make创建时就是返回的对应指针：</p>
<pre><code class="language-go">func makemap(t *maptype, hint int, h *hmap) *hmap {
    // 在 64 位系统上 hmap 结构体大小为 48 字节
    // 32 位系统上是 28 字节
    if sz := unsafe.Sizeof(hmap{}); sz != 8+5*sys.PtrSize {
        println(&quot;runtime: sizeof(hmap) =&quot;, sz, &quot;, t.hmap.size =&quot;, t.hmap.size)
        throw(&quot;bad hmap size&quot;)
    }

    if hint &lt; 0 || hint &gt; int(maxSliceCap(t.bucket.size)) {
        hint = 0
    }

    // 初始化 hmap
    if h == nil {
        h = (*hmap)(newobject(t.hmap))
    }
    h.hash0 = fastrand()

    // 按照提供的元素个数，找一个可以放得下这么多元素的 B 值
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // 分配初始的 hash table
    // 如果 B == 0，buckets 字段会由 mapassign 来 lazily 分配
    // 因为如果 hint 很大的话，对这部分内存归零会花比较长时间
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B)
        if nextOverflow != nil {
            h.extra = new(mapextra)
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
</code></pre>
<p>参考资料：<br>
<a href="https://github.com/cch123/golang-notes/blob/master/map.md">曹大map源码分析</a><br>
<a href="https://www.jianshu.com/p/aa0d4808cbb8">Golang map 的底层实现</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go RPC对比和示例]]></title>
        <id>https://meetbetter.github.io/post/go-rpc-learning-1</id>
        <link href="https://meetbetter.github.io/post/go-rpc-learning-1">
        </link>
        <updated>2018-09-15T08:14:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="说明">说明</h1>
<p>做项目中发现自己对很多东西的理解有偏差，所以决定做个总结，也分享给需要的朋友。如有错误和遗漏，欢迎沟通交流。</p>
<p><a href="https://github.com/meetbetter/gRPC-Demo">GitHub示例源码</a></p>
<p>本文介绍了Go中原生和第三方RPC使用方法，环境搭建方法并提供了材料。</p>
<h1 id="rpc">RPC</h1>
<p>远程过程调用(Remote Procedure Call)，通俗的说，RPC可以实现跨机器、跨语言调用其他计算机的程序。举个例子，我在机器A上用C语言封装了某个功能的函数，我可以通过RPC在机器B上用GO语言调用机器A上的指定函数。<br>
RPC为C/S模型，通常使用TCP或http协议。</p>
<h1 id="golang官方rpc">Golang官方RPC</h1>
<p>go RPC可以利用tcp或http来传递数据，可以对要传递的数据使用多种类型的编解码方式。</p>
<h2 id="netrpc库">net/rpc库</h2>
<p>Golang官方的net/rpc库可以通过tcp或http传递数据，但net/rpc库使用encoding/gob进行编解码，支持tcp或http数据传输方式，由于其他语言不支持gob编解码方式，所以使用net/rpc库实现的RPC方法没办法进行跨语言调用。</p>
<h3 id="server端代码">server端代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;net&quot;
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type Chen struct {
}

//rcp方法
//func (t *T) MethodName(argType T1, replyType *T2) error
func (this *Chen) GetAdd(data int, sum *int) error {

	*sum = data + 100

	return nil
}

func main() {
	//1.对象实例化
	pd := new(Chen)
	//2. rpc注册
	rpc.Register(pd)
	//3. rpc网络
	rpc.HandleHTTP()
	//4. 监听网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}
	//5. 等待连接
	http.Serve(ln, nil)
}
</code></pre>
<h3 id="client代码">client代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;fmt&quot;
)

func main() {
	//1. 连接服务器
	cln, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;rpc.Dial error:&quot;, err)
		return
	}
	defer cln.Close()

	//2. 调用服务器函数
	var data int
	err = cln.Call(&quot;Chen.GetAdd&quot;,10, &amp;data)
	if err != nil {
		fmt.Println(&quot;cln.Call error:&quot;, err)
		return
	}
	//3. 打印输出
	fmt.Println(&quot;计算结果为:&quot;, data)
}
</code></pre>
<h3 id="运行结果">运行结果</h3>
<p>客户端输出：<code>计算结果为: 110</code></p>
<h2 id="netrpcjsonrpc库">net/rpc/jsonrpc库</h2>
<p>Go官方还提供了使用json编解码的rpc库：net/rpc/jsonrpc，但是使用tcp传递数据，不能用http。</p>
<h3 id="server代码">server代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;net&quot;
	&quot;fmt&quot;
	&quot;net/rpc/jsonrpc&quot;
)

type Chen struct {
}

//rcp方法
//func (t *T) MethodName(argType T1, replyType *T2) error
func (this *Chen) GetAdd(data int, sum *int) error {

	*sum = data + 100

	return nil
}

func main() {
	//1.对象实例化
	pd := new(Chen)
	//2. rpc注册
	rpc.Register(pd)

	//3. 监听网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}

	//4. 处理客户端请求
	for {
		conn, err := ln.Accept()
		if err != nil {
			fmt.Println(&quot;Accept error:&quot;, err)
			continue
		}

		go func(conn net.Conn) {
			jsonrpc.ServeConn(conn)
		}(conn)
	}
}
</code></pre>
<h3 id="client代码-2">client代码</h3>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;net/rpc/jsonrpc&quot;
)

func main() {
	//1. 连接服务器
	cln, err := jsonrpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;jsonrpc.Dial error:&quot;, err)
		return
	}
	defer cln.Close()

	//2. 调用服务器函数
	var data int
	err = cln.Call(&quot;Chen.GetAdd&quot;,10, &amp;data)
	if err != nil {
		fmt.Println(&quot;cln.Call error:&quot;, err)
		return
	}
	//3. 打印输出
	fmt.Println(&quot;计算结果为:&quot;, data)
}
</code></pre>
<h3 id="运行结果-2">运行结果</h3>
<p>客户端输出：<code>计算结果为: 110</code></p>
<h1 id="grpc">gRPC</h1>
<p>所以为了真正实现跨主机、跨语言的远程调用，需要使用第三方的RPC库，推荐使用谷歌开源的gRPC。gRPC基于HTTP/2，采用protobuf进行数据编解码，压缩和传输效率更高。可以参考本人的<a href="https://github.com/meetbetter/protocol-buffer-demo">Go语言protobuf入门</a>了解Go语言protobuf的环境搭建和使用。</p>
<h2 id="grpc安装">gRPC安装</h2>
<p>由于不能直接访问golang官网，所以安装gPRC和go扩展包比较麻烦，可以从本人<a href="https://github.com/meetbetter/gRPC-Demo">gRPC环境包安装</a>中获取压缩包。</p>
<pre><code class="language-shell">unzip x.zip -d /$GOPATH/src/golang.org/x
unzip google.golang.org.zip -d /$GOPATH/src/google.golang.org
</code></pre>
<h2 id="grpc环境测试">gRPC环境测试</h2>
<p>启动服务器端，</p>
<pre><code class="language-shell">$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld/greeter_server
$ go run main.go
</code></pre>
<p>启动客户端，</p>
<pre><code class="language-shell">$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld/greeter_client
$ go run main.go
</code></pre>
<p>如果客户端打印出<code>2019/06/10 15:26:12 Greeting: Hello world</code>字样即表示gRPC环境正常。</p>
<h2 id="建立proto文件">建立proto文件</h2>
<pre><code class="language-protobuf">//版本
syntax = &quot;proto3&quot;;

//包名
package myproto;

//服务
service Hello {
    //这儿注释才有效
    rpc GetAdd(In)returns(Out);//这儿注释无效
}

//传入
message In {
    //此处1不是赋值，而是指参数序号
    int64 num = 1;
}

//传出
message Out {
    //此处1不是赋值，而是指参数序号
    int64 size = 1;
}
</code></pre>
<h2 id="生成go代码">生成go代码</h2>
<p>在.proto文件所在目录执行下面的指令，</p>
<pre><code class="language-shell">protoc --go_out=plugins=grpc:./ *.proto
</code></pre>
<blockquote>
<p>生成go代码时要指定plugins=grpc表示生成的是gRPC代码。</p>
</blockquote>
<h2 id="服务端代码">服务端代码</h2>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	pb &quot;gRPC/myproto&quot; //给package起别名
	&quot;context&quot;
	&quot;net&quot;
	&quot;google.golang.org/grpc&quot;
)

//1. 结构体
type Chen struct {

}

//2. 该结构体实现HelloServer interface的方法
func (this *Chen)GetAdd(ctx context.Context, In *pb.In)(*pb.Out,error)  {
	return &amp;pb.Out{Size:In.Num+100},nil
}

func main() {
	fmt.Println(&quot;server runing...&quot;)

	//3. 创建网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12345&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}
	defer ln.Close()

	//4. 创建gRPC句柄
	srv := grpc.NewServer()

	//5. 注册server
	pb.RegisterHelloServer(srv, &amp;Chen{})

	//6. 等待网络连接
	err = srv.Serve(ln)
	if err != nil {
		fmt.Println(&quot;srv.Serve error:&quot;, err)
		return
	}

}
</code></pre>
<h2 id="客户端代码">客户端代码</h2>
<pre><code class="language-go">package main

import (
	&quot;google.golang.org/grpc&quot;
	&quot;fmt&quot;
	pb &quot;gRPC/myproto&quot;
	&quot;context&quot;
)

func main() {
	//1 连接服务器
	conn, err := grpc.Dial(&quot;127.0.0.1:12345&quot;,grpc.WithInsecure())//grpc.WithInsecure()指定后才不会报错
	if err != nil {
		fmt.Println(&quot;grpc.Dial error:&quot;, err)
		return
	}
	defer conn.Close()

	//2 创建客户端句柄
	cln := pb.NewHelloClient(conn)

	//3 调用服务器函数(RPC)
	out,err := cln.GetAdd(context.Background(), &amp;pb.In{Num:10})
	if err != nil {
		fmt.Println(&quot;grpc.Dial error:&quot;, err)
		return
	}

	//4 打印
	fmt.Println(&quot;得到数据:&quot;, out.Size)
}

</code></pre>
<h2 id="运行测试">运行测试</h2>
<p>先后运行服务器和客户端代码，可在客户端打印输出<code>得到数据: 110</code>，说明已经成功在客户端调用服务端程序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go slice：切片的“陷阱”和本质]]></title>
        <id>https://meetbetter.github.io/post/go-sliceqie-pian-de-xian-jing-he-ben-zhi</id>
        <link href="https://meetbetter.github.io/post/go-sliceqie-pian-de-xian-jing-he-ben-zhi">
        </link>
        <updated>2018-04-26T03:59:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="文章说明">文章说明</h1>
<p>总结了go语言中切片slice的特殊性和使用时的注意事项。</p>
<p>个人理解，不足之处欢迎指出。</p>
<p>slice：切片，是go语言中一种常用的数据结构，基于数组构建，表示相同数据类型的集合。</p>
<h1 id="数组">数组</h1>
<p>Go中数组类型表示固定长度的相同类型的数据的集合，数据在内存中连续存储，可以通过下标索引，但是又有特殊的地方：</p>
<ul>
<li>数组是值类型，一个数组变量表示整个数组，而不是指向数组的首元素的指针，这和C语言不同。</li>
<li>将数组赋值给另一个数组，或者数组作函数参数传递时，会将数组的全部数据拷贝一份过去而不是传递一个指针。</li>
<li>数组类型包括长度，即[5]int和[10]不是一种类型。</li>
</ul>
<p>所以Go语言中使用数组传递数据效率很低，通常使用切片。</p>
<h1 id="切片">切片</h1>
<p>切片是一个数组片段的描述，包含了指向数组片段的指针，片段的长度len和容量cap（数组片段的最大长度），但是<strong>切片本身并不是真正的指针类型</strong>。</p>
<h2 id="切片的特性">切片的特性</h2>
<ol>
<li>可以自动扩容<br>
使用append()向切片<strong>追加</strong>数据，数据是被添加到切片指向的片段末尾，长度等于容量时切片就会自动扩容，扩容的细节后面的文章再讨论。</li>
<li>切片之间赋值或者切片作函数参数传递时，是将指向数组片段的指针传递过去，所以改变一个会影响另一个。</li>
</ol>
<h2 id="切片的陷阱">切片的陷阱</h2>
<p>切片作函数参数传递或浅拷贝时，之所以改变一个切片的数据会影响另一个切片，是因为两个切片中中包含了指向同一数组片段的指针。</p>
<p>一切看似正常？但是当一个切片发生扩容时，会将当前切片内的数据复制到另一片内存区域，该切片的数组片段的地址发生改变，所以当切片扩容时修改一个切片的数据时不会再影响到另一个切片！此时只能通过传递切片本身的地址来解决。</p>
<p>扩容时出错的代码如下：</p>
<pre><code>package main

import &quot;fmt&quot;

func testSlice(slice []int) {
slice = append(slice, 6, 7, 8, 9, 10)
fmt.Println(&quot;testSlice:&quot;,slice)
}
func main() {
slice := []int{1, 2, 3, 4, 5}

	testSlice(slice)
fmt.Println(&quot;main:&quot;,slice)
}
</code></pre>
<h1 id="切片的本质">切片的本质</h1>
<p>可以证明，<strong>切片不是指针类型，切片数据类型是包含指向一个数组片段的指针，和当前数组片段的长度，以及当前数组最大容量的一种复合数据结构</strong>。</p>
<p>想深入了解Go中slice数据类型的底层实现，可以参考本人的Github<a href="https://github.com/meetbetter/learn-golang/blob/master/02_advance/01_data_structure/01-slice.go">自己动手实现Go切片数据结构</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WSL(Windows Subsystem for Linux)安装与使用]]></title>
        <id>https://meetbetter.github.io/post/win10-wsl</id>
        <link href="https://meetbetter.github.io/post/win10-wsl">
        </link>
        <updated>2018-02-27T11:39:03.000Z</updated>
        <content type="html"><![CDATA[<p>本文详细介绍了Windows10子系统Linux(WSL)的安装和配合Goland、vscode的使用方法，个人感觉WSL使得后台开发变得很方便，特此分享出来。<br>
官方介绍：WSL(Windows Subsystem for Linux)是适用于Linux 的 Windows 子系统，是一个为在Windows 10和Windows Server 2019上能够原生运行Linux二进制可执行文件的兼容层。</p>
<p>直白的讲，就是<strong>借助WSL可以在Windows10中直接编译出Linux环境的可执行文件，让Windows下的开发有机会摆脱庞大的虚拟机</strong>，有点mac下开发的感觉，特别适合我这种没有mac的贫困码农。</p>
<h1 id="打开子系统功能">打开子系统功能</h1>
<p>在win10 power shell输入如下指令：</p>
<pre><code class="language-shell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
</code></pre>
<h1 id="win10-安装ubuntu">win10 安装Ubuntu</h1>
<p>从win10应用商店安装Ubuntu：<br>
<img src="https://meetbetter.github.io/post-images/1564114438785.jpg" alt=""><br>
安装后win10桌面会提示设置用户名和密码：<br>
<img src="https://meetbetter.github.io/post-images/1564123550388.png" alt=""></p>
<h1 id="go环境配置">GO环境配置</h1>
<h2 id="goroot配置">GOROOT配置</h2>
<h3 id="配置共享目录">配置共享目录</h3>
<p>为了方便的在Windows和WSL之间拷贝文件，要先设置共享目录。<br>
WSL中的<code>/mnt/c/Users/HideOnBush/</code>路径为Windows10在Linux下的挂载分区，为方便和win10共享文件，在Windows中新建UbuntuShare文件夹，在WSL添加软链接：</p>
<pre><code class="language-shell">ln -s /mnt/c/Users/HideOnBush/UbuntuShare/ win10
</code></pre>
<blockquote>
<p>HideOnBush是我的Windows中的用户名，需要替换为你实际的Windows用户名哦。</p>
</blockquote>
<h3 id="wsl安装go">WSL安装Go</h3>
<p>从<a href="https://studygolang.com/dl">go语言中文网</a>下载Linux go安装包(我使用的是1.12.5)，放到刚才设置的共享目录中，就可以在WSL中操作了。<br>
解压到/usr/local：</p>
<pre><code class="language-shell">cd win10
sudo tar -xzf go1.12.5.linux-amd64.tar.gz -C /usr/local/
</code></pre>
<h2 id="gopath配置">GOPATH配置</h2>
<p>将Windows和Linux的GOPATH设置为同一个路径，就可以实现在win10写代码时和在Linux编代码共用一套第三方包。</p>
<h3 id="查看win10环境变量">查看win10环境变量</h3>
<p><img src="https://meetbetter.github.io/post-images/1564115020270.png" alt=""><br>
<img src="https://meetbetter.github.io/post-images/1564115125234.png" alt=""><br>
可以看到我的Windows中GOPATH路径为<code>Users/HideOnBush/go</code>，接下来将WSL中的GOPATH设置为同一路径，完成后续操作就可以方便的在Windows中编写代码并调用Ubuntu编译代码了。</p>
<h3 id="设置wsl-gopath">设置wsl GOPATH：</h3>
<pre><code class="language-go">vim ~/.bashrc
</code></pre>
<p>末尾添加：</p>
<pre><code class="language-shell">export GOPATH=/mnt/c/Users/HideOnBush/go
export GOROOT=/usr/local/go
export PATH=$GOROOT/bin:$PATH
</code></pre>
<p>使修改立即生效：</p>
<pre><code class="language-shell">source .bashrc
</code></pre>
<p>使用<code>go env</code>查看GOPATH是否配置成功：</p>
<p><img src="https://meetbetter.github.io/post-images/1564116197193.png" alt=""><br>
可以看到我的GOPATH已经设置为和Windows中的GOPATH一致了。</p>
<h1 id="更新软件源">更新软件源</h1>
<pre><code class="language-shell">sudo cp /etc/apt/sources.list /etc/apt/sources.list_origin
sudo vim /etc/apt/sources.list
</code></pre>
<pre><code class="language-shell">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
</code></pre>
<pre><code class="language-shell">sudo apt-get update //更新源
sudo apt-get upgrade //根据软件源的信息更新软件
</code></pre>
<h1 id="在windows中调用wsl-bash">在Windows中调用WSL bash</h1>
<p>接下来根据你使用的编译器，将编译器使用的bash修改为WSL内的bash，就可以在Windows下编译出Linux下的可执行文件。</p>
<h2 id="配合goland-使用">配合goland 使用</h2>
<h3 id="修改bash为wsl所在路径">修改bash为wsl所在路径</h3>
<p>找到wsl命令行所在路径，<br>
<img src="https://meetbetter.github.io/post-images/1564123762337.jpg" alt=""></p>
<p>设置goland &quot;shell path&quot;,<br>
<img src="https://meetbetter.github.io/post-images/1564123785522.jpg" alt=""><br>
修改goland换行符为UINX下的LF：<br>
<img src="https://meetbetter.github.io/post-images/1564123833128.jpg" alt=""></p>
<p>terminal测试，<br>
<img src="https://meetbetter.github.io/post-images/1564123793665.jpg" alt=""></p>
<blockquote>
<p>不能直接使用goland的run图标运行，因为goland默认使用的是Windows中的编译环境，必须要在terminal中编译才是使用的WSL的bash编译。</p>
</blockquote>
<h2 id="配合vs-code使用">配合vs code使用</h2>
<p>安装wsl后在vscode terminal可以看到wsl（windows system linux）的窗口，就可以在这儿方便操作Linux。<br>
<img src="https://meetbetter.github.io/post-images/1564123717689.jpg" alt=""></p>
<p>为了防止和Linux内编写的文件换行符有冲突，推荐修改换行符为Linux样式，如下：<br>
<img src="https://meetbetter.github.io/post-images/1564123732107.jpg" alt=""></p>
<p>至此，Windows10的Linux子系统的开发环境已经基本搭建完成，后续根据你的需要在WSL安装对应工具即可，如果觉得WSL的命令行太难用，可以使用Goland的terminal，或者使用Secure CRT等SSH工具。</p>
]]></content>
    </entry>
</feed>