<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://meetbetter.github.io</id>
    <title>Betterman</title>
    <updated>2019-07-15T10:44:24.019Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://meetbetter.github.io"/>
    <link rel="self" href="https://meetbetter.github.io/atom.xml"/>
    <subtitle>我的小屋
在星星下面 在城市的楼群之间</subtitle>
    <logo>https://meetbetter.github.io/images/avatar.png</logo>
    <icon>https://meetbetter.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Betterman</rights>
    <entry>
        <title type="html"><![CDATA[GitHub pages + gridea:一键搭建个人博客]]></title>
        <id>https://meetbetter.github.io/post/github-pages-gridea</id>
        <link href="https://meetbetter.github.io/post/github-pages-gridea">
        </link>
        <updated>2019-03-22T09:00:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="注册个人域名">注册个人域名</h1>
<h1 id="绑定个人域名">绑定个人域名</h1>
<p>**问题：**Grida会配置个人域名时会删除github中的CNAME，导致域名不可达。<br>
<img src="https://meetbetter.github.io/post-images/1563181533762.png" alt=""><br>
原因：<br>
<img src="https://meetbetter.github.io/post-images/1563183866574.png" alt=""><br>
解决办法<br>
<img src="https://meetbetter.github.io/post-images/1563183843618.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go RPC对比和示例]]></title>
        <id>https://meetbetter.github.io/post/go-rpc-learning-1</id>
        <link href="https://meetbetter.github.io/post/go-rpc-learning-1">
        </link>
        <updated>2018-12-15T08:14:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="说明">说明</h1>
<p>做项目中发现自己对很多东西的理解有偏差，所以决定做个总结，也分享给需要的朋友。如有错误和遗漏，欢迎沟通交流。</p>
<p><a href="https://github.com/meetbetter/gRPC-Demo">GitHub示例源码</a></p>
<p>本文介绍了Go中原生和第三方RPC使用方法，环境搭建方法并提供了材料。</p>
<h1 id="rpc">RPC</h1>
<p>远程过程调用(Remote Procedure Call)，通俗的说，RPC可以实现跨机器、跨语言调用其他计算机的程序。举个例子，我在机器A上用C语言封装了某个功能的函数，我可以通过RPC在机器B上用GO语言调用机器A上的指定函数。<br>
RPC为C/S模型，通常使用TCP或http协议。</p>
<h1 id="golang官方rpc">Golang官方RPC</h1>
<p>go RPC可以利用tcp或http来传递数据，可以对要传递的数据使用多种类型的编解码方式。</p>
<h2 id="netrpc库">net/rpc库</h2>
<p>Golang官方的net/rpc库可以通过tcp或http传递数据，但net/rpc库使用encoding/gob进行编解码，支持tcp或http数据传输方式，由于其他语言不支持gob编解码方式，所以使用net/rpc库实现的RPC方法没办法进行跨语言调用。</p>
<h3 id="server端代码">server端代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;net&quot;
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type Chen struct {
}

//rcp方法
//func (t *T) MethodName(argType T1, replyType *T2) error
func (this *Chen) GetAdd(data int, sum *int) error {

	*sum = data + 100

	return nil
}

func main() {
	//1.对象实例化
	pd := new(Chen)
	//2. rpc注册
	rpc.Register(pd)
	//3. rpc网络
	rpc.HandleHTTP()
	//4. 监听网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}
	//5. 等待连接
	http.Serve(ln, nil)
}
</code></pre>
<h3 id="client代码">client代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;fmt&quot;
)

func main() {
	//1. 连接服务器
	cln, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;rpc.Dial error:&quot;, err)
		return
	}
	defer cln.Close()

	//2. 调用服务器函数
	var data int
	err = cln.Call(&quot;Chen.GetAdd&quot;,10, &amp;data)
	if err != nil {
		fmt.Println(&quot;cln.Call error:&quot;, err)
		return
	}
	//3. 打印输出
	fmt.Println(&quot;计算结果为:&quot;, data)
}
</code></pre>
<h3 id="运行结果">运行结果</h3>
<p>客户端输出：<code>计算结果为: 110</code></p>
<h2 id="netrpcjsonrpc库">net/rpc/jsonrpc库</h2>
<p>Go官方还提供了使用json编解码的rpc库：net/rpc/jsonrpc，但是使用tcp传递数据，不能用http。</p>
<h3 id="server代码">server代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;net&quot;
	&quot;fmt&quot;
	&quot;net/rpc/jsonrpc&quot;
)

type Chen struct {
}

//rcp方法
//func (t *T) MethodName(argType T1, replyType *T2) error
func (this *Chen) GetAdd(data int, sum *int) error {

	*sum = data + 100

	return nil
}

func main() {
	//1.对象实例化
	pd := new(Chen)
	//2. rpc注册
	rpc.Register(pd)

	//3. 监听网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}

	//4. 处理客户端请求
	for {
		conn, err := ln.Accept()
		if err != nil {
			fmt.Println(&quot;Accept error:&quot;, err)
			continue
		}

		go func(conn net.Conn) {
			jsonrpc.ServeConn(conn)
		}(conn)
	}
}
</code></pre>
<h3 id="client代码-2">client代码</h3>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;net/rpc/jsonrpc&quot;
)

func main() {
	//1. 连接服务器
	cln, err := jsonrpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;jsonrpc.Dial error:&quot;, err)
		return
	}
	defer cln.Close()

	//2. 调用服务器函数
	var data int
	err = cln.Call(&quot;Chen.GetAdd&quot;,10, &amp;data)
	if err != nil {
		fmt.Println(&quot;cln.Call error:&quot;, err)
		return
	}
	//3. 打印输出
	fmt.Println(&quot;计算结果为:&quot;, data)
}
</code></pre>
<h3 id="运行结果-2">运行结果</h3>
<p>客户端输出：<code>计算结果为: 110</code></p>
<h1 id="grpc">gRPC</h1>
<p>所以为了真正实现跨主机、跨语言的远程调用，需要使用第三方的RPC库，推荐使用谷歌开源的gRPC。gRPC基于HTTP/2，采用protobuf进行数据编解码，压缩和传输效率更高。可以参考本人的<a href="https://github.com/meetbetter/protocol-buffer-demo">Go语言protobuf入门</a>了解Go语言protobuf的环境搭建和使用。</p>
<h2 id="grpc安装">gRPC安装</h2>
<p>由于不能直接访问golang官网，所以安装gPRC和go扩展包比较麻烦，可以从本人<a href="https://github.com/meetbetter/gRPC-Demo">gRPC环境包安装</a>中获取压缩包。</p>
<pre><code class="language-shell">unzip x.zip -d /$GOPATH/src/golang.org/x
unzip google.golang.org.zip -d /$GOPATH/src/google.golang.org
</code></pre>
<h2 id="grpc环境测试">gRPC环境测试</h2>
<p>启动服务器端，</p>
<pre><code class="language-shell">$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld/greeter_server
$ go run main.go
</code></pre>
<p>启动客户端，</p>
<pre><code class="language-shell">$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld/greeter_client
$ go run main.go
</code></pre>
<p>如果客户端打印出<code>2019/06/10 15:26:12 Greeting: Hello world</code>字样即表示gRPC环境正常。</p>
<h2 id="建立proto文件">建立proto文件</h2>
<pre><code class="language-protobuf">//版本
syntax = &quot;proto3&quot;;

//包名
package myproto;

//服务
service Hello {
    //这儿注释才有效
    rpc GetAdd(In)returns(Out);//这儿注释无效
}

//传入
message In {
    //此处1不是赋值，而是指参数序号
    int64 num = 1;
}

//传出
message Out {
    //此处1不是赋值，而是指参数序号
    int64 size = 1;
}
</code></pre>
<h2 id="生成go代码">生成go代码</h2>
<p>在.proto文件所在目录执行下面的指令，</p>
<pre><code class="language-shell">protoc --go_out=plugins=grpc:./ *.proto
</code></pre>
<blockquote>
<p>生成go代码时要指定plugins=grpc表示生成的是gRPC代码。</p>
</blockquote>
<h2 id="服务端代码">服务端代码</h2>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	pb &quot;gRPC/myproto&quot; //给package起别名
	&quot;context&quot;
	&quot;net&quot;
	&quot;google.golang.org/grpc&quot;
)

//1. 结构体
type Chen struct {

}

//2. 该结构体实现HelloServer interface的方法
func (this *Chen)GetAdd(ctx context.Context, In *pb.In)(*pb.Out,error)  {
	return &amp;pb.Out{Size:In.Num+100},nil
}

func main() {
	fmt.Println(&quot;server runing...&quot;)

	//3. 创建网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12345&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}
	defer ln.Close()

	//4. 创建gRPC句柄
	srv := grpc.NewServer()

	//5. 注册server
	pb.RegisterHelloServer(srv, &amp;Chen{})

	//6. 等待网络连接
	err = srv.Serve(ln)
	if err != nil {
		fmt.Println(&quot;srv.Serve error:&quot;, err)
		return
	}

}
</code></pre>
<h2 id="客户端代码">客户端代码</h2>
<pre><code class="language-go">package main

import (
	&quot;google.golang.org/grpc&quot;
	&quot;fmt&quot;
	pb &quot;gRPC/myproto&quot;
	&quot;context&quot;
)

func main() {
	//1 连接服务器
	conn, err := grpc.Dial(&quot;127.0.0.1:12345&quot;,grpc.WithInsecure())//grpc.WithInsecure()指定后才不会报错
	if err != nil {
		fmt.Println(&quot;grpc.Dial error:&quot;, err)
		return
	}
	defer conn.Close()

	//2 创建客户端句柄
	cln := pb.NewHelloClient(conn)

	//3 调用服务器函数(RPC)
	out,err := cln.GetAdd(context.Background(), &amp;pb.In{Num:10})
	if err != nil {
		fmt.Println(&quot;grpc.Dial error:&quot;, err)
		return
	}

	//4 打印
	fmt.Println(&quot;得到数据:&quot;, out.Size)
}

</code></pre>
<h2 id="运行测试">运行测试</h2>
<p>先后运行服务器和客户端代码，可在客户端打印输出<code>得到数据: 110</code>，说明已经成功在客户端调用服务端程序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang protobuf快速上手]]></title>
        <id>https://meetbetter.github.io/post/golang-protobuf-learning</id>
        <link href="https://meetbetter.github.io/post/golang-protobuf-learning">
        </link>
        <updated>2018-10-15T08:08:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="说明">说明</h1>
<p><a href="https://github.com/meetbetter/protocol-buffer-demo">Demo源码</a></p>
<p>protocol buffer是谷歌推出的高效率序列化反序列化工具，可以自定义数据结构，然后使用对应语言的代码生成器生成的代码读写这个数据结构。虽然在和前端打交道时还是要配合使用JSON，但是在其他场合可以尝试使用protocol buffer改进性能。</p>
<p>下面总结下在GoLang中使用protocol buffer的方法。</p>
<h1 id="go环境配置">Go环境配置</h1>
<h2 id="下载protobuf">下载protobuf</h2>
<pre><code class="language-shell">git clone https://github.com/protocolbuffers/protobuf.git
</code></pre>
<h2 id="安装linux-ubuntu">安装(Linux Ubuntu)</h2>
<h3 id="1安装依赖工具">(1)安装依赖工具</h3>
<pre><code class="language-shell">sudo apt-get install autoconf automake libtool curl make g++ unzip libffi-dev -y
</code></pre>
<h3 id="2进入protobuf文件">(2)进入protobuf文件</h3>
<pre><code class="language-shell">cd protobuf/
</code></pre>
<h3 id="3进行安装检测-并生成自动安装脚本">(3)进行安装检测 并生成自动安装脚本</h3>
<pre><code class="language-shell">./autogen.sh
./configure
</code></pre>
<h3 id="4进行编译c代码和安装">(4)进行编译C代码和安装</h3>
<pre><code class="language-shell">make
sudo make install
</code></pre>
<h3 id="5刷新linux共享库关系">(5)刷新linux共享库关系</h3>
<pre><code class="language-shell">sudo ldconfig
</code></pre>
<h3 id="6测试protobuf编译工具">(6)测试protobuf编译工具</h3>
<pre><code class="language-shell">protoc -h
</code></pre>
<p>如果正常输出 相关指令 没有报任何error，为安装成功。</p>
<h2 id="获取-golang的proto包">获取 GoLang的proto包</h2>
<h3 id="1下载">(1)下载</h3>
<pre><code class="language-shell">go get -v -u github.com/golang/protobuf/proto
</code></pre>
<h3 id="2进入到文件夹内进行编译">(2)进入到文件夹内进行编译</h3>
<pre><code class="language-shell">cd $GOPATH/src/github.com/golang/protobuf/protoc-gen-go/
go build
</code></pre>
<h3 id="3拷贝可执行文件">(3)拷贝可执行文件</h3>
<p>将生成的 protoc-gen-go可执行文件，放在/bin目录下。</p>
<pre><code class="language-shell">sudo cp protoc-gen-go /bin/
</code></pre>
<p>尝试补齐protoc-gen-go 如果可以补齐代表成功，如果执行不报错 代表工具成功。</p>
<h1 id="go使用protobuf">Go使用protobuf</h1>
<h2 id="新建proto文件">新建.proto文件</h2>
<p>基本格式如下：</p>
<pre><code class="language-protobuf">syntax = &quot;proto3&quot;; //必须指定protobuf协议版本号
package pb; //包名

//定义一个protobuf协议
message Person {
    string name = 1; //数字表示序号，并不是变量值.
    int32 age = 2;
    repeated string hobby = 3; //对应go中[]string

}
</code></pre>
<h2 id="生成go数据结构">生成Go数据结构</h2>
<p>在.proto所在目录执行如下命令，</p>
<pre><code class="language-shell">protoc --go_out=.  *.proto
</code></pre>
<p>在当前目录下会生成对应的.go文件，可以在其中找到go的数据结构，</p>
<pre><code class="language-go">type Person struct {
	Name                 string   `protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`
	Age                  int32    `protobuf:&quot;varint,2,opt,name=age,proto3&quot; json:&quot;age,omitempty&quot;`
	Hobby                []string `protobuf:&quot;bytes,3,rep,name=hobby,proto3&quot; json:&quot;hobby,omitempty&quot;`
	XXX_NoUnkeyedLiteral struct{} `json:&quot;-&quot;`
	XXX_unrecognized     []byte   `json:&quot;-&quot;`
	XXX_sizecache        int32    `json:&quot;-&quot;`
}
</code></pre>
<p><strong>注意</strong>，该文件只能生成不能手动修改。</p>
<h2 id="使用protobuf">使用protobuf</h2>
<p>在main函数中新建Person对象并进行序列化和反序列化，</p>
<pre><code class="language-go">package main

import (
	&quot;protobufDemo/pb&quot;
	&quot;github.com/golang/protobuf/proto&quot;
	&quot;fmt&quot;
)

func main() {

	//序列化
	person := &amp;pb.Person{
		Name:&quot;Jack&quot;,
		Age:18,
		Hobby:[]string{&quot;sing&quot;,&quot;dance&quot;,&quot;basketball&quot;,&quot;rap&quot;},
	}

	binaryData, err := proto.Marshal(person)
	if err != nil {
		fmt.Println(&quot;proto.Marshal err:&quot;,err)
	}

	//反序列化
	newPerson := &amp;pb.Person{}
	err = proto.Unmarshal(binaryData,newPerson)
	if err != nil {
		fmt.Println(&quot;proto.Unmarshal err:&quot;,err)
	}

	fmt.Println(&quot;序列化前的原始数据:&quot;,person)
	fmt.Println(&quot;反序列化得到数据:&quot;,newPerson)
}

</code></pre>
<p>执行后可以看到person和newPerson都喜欢<strong>唱、跳、篮球和rap</strong>。</p>
<pre><code class="language-shell">序列化前的原始数据: name:&quot;Jack&quot; age:18 hobby:&quot;sing&quot; hobby:&quot;dance&quot; hobby:&quot;basketball&quot; hobby:&quot;rap&quot; 
反序列化得到数据: name:&quot;Jack&quot; age:18 hobby:&quot;sing&quot; hobby:&quot;dance&quot; hobby:&quot;basketball&quot; hobby:&quot;rap&quot;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go slice：切片的“陷阱”和本质]]></title>
        <id>https://meetbetter.github.io/post/go-sliceqie-pian-de-xian-jing-he-ben-zhi</id>
        <link href="https://meetbetter.github.io/post/go-sliceqie-pian-de-xian-jing-he-ben-zhi">
        </link>
        <updated>2018-09-12T03:59:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="文章说明">文章说明</h1>
<p>总结了go语言中切片slice的特殊性和使用时的注意事项。</p>
<p>个人理解，不足之处欢迎指出。</p>
<p>slice：切片，是go语言中一种常用的数据结构，基于数组构建，表示相同数据类型的集合。</p>
<h1 id="数组">数组</h1>
<p>Go中数组类型表示固定长度的相同类型的数据的集合，数据在内存中连续存储，可以通过下标索引，但是又有特殊的地方：</p>
<ul>
<li>数组是值类型，一个数组变量表示整个数组，而不是指向数组的首元素的指针，这和C语言不同。</li>
<li>将数组赋值给另一个数组，或者数组作函数参数传递时，会将数组的全部数据拷贝一份过去而不是传递一个指针。</li>
<li>数组类型包括长度，即[5]int和[10]不是一种类型。</li>
</ul>
<p>所以Go语言中使用数组传递数据效率很低，通常使用切片。</p>
<h1 id="切片">切片</h1>
<p>切片是一个数组片段的描述，包含了指向数组片段的指针，片段的长度len和容量cap（数组片段的最大长度），但是<strong>切片本身并不是真正的指针类型</strong>。</p>
<h2 id="切片的特性">切片的特性</h2>
<ol>
<li>可以自动扩容<br>
使用append()向切片<strong>追加</strong>数据，数据是被添加到切片指向的片段末尾，长度等于容量时切片就会自动扩容，扩容的细节后面的文章再讨论。</li>
<li>切片之间赋值或者切片作函数参数传递时，是将指向数组片段的指针传递过去，所以改变一个会影响另一个。</li>
</ol>
<h2 id="切片的陷阱">切片的陷阱</h2>
<p>切片作函数参数传递或浅拷贝时，之所以改变一个切片的数据会影响另一个切片，是因为两个切片中中包含了指向同一数组片段的指针。</p>
<p>一切看似正常？但是当一个切片发生扩容时，会将当前切片内的数据复制到另一片内存区域，该切片的数组片段的地址发生改变，所以当切片扩容时修改一个切片的数据时不会再影响到另一个切片！此时只能通过传递切片本身的地址来解决。</p>
<p>扩容时出错的代码如下：</p>
<pre><code>package main

import &quot;fmt&quot;

func testSlice(slice []int) {
slice = append(slice, 6, 7, 8, 9, 10)
fmt.Println(&quot;testSlice:&quot;,slice)
}
func main() {
slice := []int{1, 2, 3, 4, 5}

	testSlice(slice)
fmt.Println(&quot;main:&quot;,slice)
}
</code></pre>
<h1 id="切片的本质">切片的本质</h1>
<p>所以，<strong>切片不是指针类型，切片数据类型是包含指向一个数组片段的指针，和当前数组片段的长度，以及当前数组最大容量的一种复合数据结构</strong>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://meetbetter.github.io/post/about</id>
        <link href="https://meetbetter.github.io/post/about">
        </link>
        <updated>2018-08-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<p>小小gopher，欢迎交流！</p>
<p>To be Better</p>
]]></content>
    </entry>
</feed>