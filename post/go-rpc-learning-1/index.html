<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Go RPC对比和示例 | Betterman</title>
<meta name="description" content="我的小屋
在星星下面 在城市的楼群之间">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://meetbetter.github.io/favicon.ico?v=1563184183179">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://meetbetter.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-143873677-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-143873677-1');
</script>


  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://meetbetter.github.io">
        <img src="https://meetbetter.github.io/images/avatar.png?v=1563184183179" class="site-logo">
        <h1 class="site-title">Betterman</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/meetbetter" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      我的小屋
在星星下面 在城市的楼群之间
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://meetbetter.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Go RPC对比和示例</h2>
            <div class="post-date">2018-12-15</div>
            
            <div class="post-content">
              <h1 id="说明">说明</h1>
<p>做项目中发现自己对很多东西的理解有偏差，所以决定做个总结，也分享给需要的朋友。如有错误和遗漏，欢迎沟通交流。</p>
<p><a href="https://github.com/meetbetter/gRPC-Demo">GitHub示例源码</a></p>
<p>本文介绍了Go中原生和第三方RPC使用方法，环境搭建方法并提供了材料。</p>
<h1 id="rpc">RPC</h1>
<p>远程过程调用(Remote Procedure Call)，通俗的说，RPC可以实现跨机器、跨语言调用其他计算机的程序。举个例子，我在机器A上用C语言封装了某个功能的函数，我可以通过RPC在机器B上用GO语言调用机器A上的指定函数。<br>
RPC为C/S模型，通常使用TCP或http协议。</p>
<h1 id="golang官方rpc">Golang官方RPC</h1>
<p>go RPC可以利用tcp或http来传递数据，可以对要传递的数据使用多种类型的编解码方式。</p>
<h2 id="netrpc库">net/rpc库</h2>
<p>Golang官方的net/rpc库可以通过tcp或http传递数据，但net/rpc库使用encoding/gob进行编解码，支持tcp或http数据传输方式，由于其他语言不支持gob编解码方式，所以使用net/rpc库实现的RPC方法没办法进行跨语言调用。</p>
<h3 id="server端代码">server端代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;net&quot;
	&quot;fmt&quot;
	&quot;net/http&quot;
)

type Chen struct {
}

//rcp方法
//func (t *T) MethodName(argType T1, replyType *T2) error
func (this *Chen) GetAdd(data int, sum *int) error {

	*sum = data + 100

	return nil
}

func main() {
	//1.对象实例化
	pd := new(Chen)
	//2. rpc注册
	rpc.Register(pd)
	//3. rpc网络
	rpc.HandleHTTP()
	//4. 监听网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}
	//5. 等待连接
	http.Serve(ln, nil)
}
</code></pre>
<h3 id="client代码">client代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;fmt&quot;
)

func main() {
	//1. 连接服务器
	cln, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;rpc.Dial error:&quot;, err)
		return
	}
	defer cln.Close()

	//2. 调用服务器函数
	var data int
	err = cln.Call(&quot;Chen.GetAdd&quot;,10, &amp;data)
	if err != nil {
		fmt.Println(&quot;cln.Call error:&quot;, err)
		return
	}
	//3. 打印输出
	fmt.Println(&quot;计算结果为:&quot;, data)
}
</code></pre>
<h3 id="运行结果">运行结果</h3>
<p>客户端输出：<code>计算结果为: 110</code></p>
<h2 id="netrpcjsonrpc库">net/rpc/jsonrpc库</h2>
<p>Go官方还提供了使用json编解码的rpc库：net/rpc/jsonrpc，但是使用tcp传递数据，不能用http。</p>
<h3 id="server代码">server代码</h3>
<pre><code class="language-go">package main

import (
	&quot;net/rpc&quot;
	&quot;net&quot;
	&quot;fmt&quot;
	&quot;net/rpc/jsonrpc&quot;
)

type Chen struct {
}

//rcp方法
//func (t *T) MethodName(argType T1, replyType *T2) error
func (this *Chen) GetAdd(data int, sum *int) error {

	*sum = data + 100

	return nil
}

func main() {
	//1.对象实例化
	pd := new(Chen)
	//2. rpc注册
	rpc.Register(pd)

	//3. 监听网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}

	//4. 处理客户端请求
	for {
		conn, err := ln.Accept()
		if err != nil {
			fmt.Println(&quot;Accept error:&quot;, err)
			continue
		}

		go func(conn net.Conn) {
			jsonrpc.ServeConn(conn)
		}(conn)
	}
}
</code></pre>
<h3 id="client代码-2">client代码</h3>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;net/rpc/jsonrpc&quot;
)

func main() {
	//1. 连接服务器
	cln, err := jsonrpc.Dial(&quot;tcp&quot;, &quot;127.0.0.1:12306&quot;)
	if err != nil {
		fmt.Println(&quot;jsonrpc.Dial error:&quot;, err)
		return
	}
	defer cln.Close()

	//2. 调用服务器函数
	var data int
	err = cln.Call(&quot;Chen.GetAdd&quot;,10, &amp;data)
	if err != nil {
		fmt.Println(&quot;cln.Call error:&quot;, err)
		return
	}
	//3. 打印输出
	fmt.Println(&quot;计算结果为:&quot;, data)
}
</code></pre>
<h3 id="运行结果-2">运行结果</h3>
<p>客户端输出：<code>计算结果为: 110</code></p>
<h1 id="grpc">gRPC</h1>
<p>所以为了真正实现跨主机、跨语言的远程调用，需要使用第三方的RPC库，推荐使用谷歌开源的gRPC。gRPC基于HTTP/2，采用protobuf进行数据编解码，压缩和传输效率更高。可以参考本人的<a href="https://github.com/meetbetter/protocol-buffer-demo">Go语言protobuf入门</a>了解Go语言protobuf的环境搭建和使用。</p>
<h2 id="grpc安装">gRPC安装</h2>
<p>由于不能直接访问golang官网，所以安装gPRC和go扩展包比较麻烦，可以从本人<a href="https://github.com/meetbetter/gRPC-Demo">gRPC环境包安装</a>中获取压缩包。</p>
<pre><code class="language-shell">unzip x.zip -d /$GOPATH/src/golang.org/x
unzip google.golang.org.zip -d /$GOPATH/src/google.golang.org
</code></pre>
<h2 id="grpc环境测试">gRPC环境测试</h2>
<p>启动服务器端，</p>
<pre><code class="language-shell">$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld/greeter_server
$ go run main.go
</code></pre>
<p>启动客户端，</p>
<pre><code class="language-shell">$ cd $GOPATH/src/google.golang.org/grpc/examples/helloworld/greeter_client
$ go run main.go
</code></pre>
<p>如果客户端打印出<code>2019/06/10 15:26:12 Greeting: Hello world</code>字样即表示gRPC环境正常。</p>
<h2 id="建立proto文件">建立proto文件</h2>
<pre><code class="language-protobuf">//版本
syntax = &quot;proto3&quot;;

//包名
package myproto;

//服务
service Hello {
    //这儿注释才有效
    rpc GetAdd(In)returns(Out);//这儿注释无效
}

//传入
message In {
    //此处1不是赋值，而是指参数序号
    int64 num = 1;
}

//传出
message Out {
    //此处1不是赋值，而是指参数序号
    int64 size = 1;
}
</code></pre>
<h2 id="生成go代码">生成go代码</h2>
<p>在.proto文件所在目录执行下面的指令，</p>
<pre><code class="language-shell">protoc --go_out=plugins=grpc:./ *.proto
</code></pre>
<blockquote>
<p>生成go代码时要指定plugins=grpc表示生成的是gRPC代码。</p>
</blockquote>
<h2 id="服务端代码">服务端代码</h2>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	pb &quot;gRPC/myproto&quot; //给package起别名
	&quot;context&quot;
	&quot;net&quot;
	&quot;google.golang.org/grpc&quot;
)

//1. 结构体
type Chen struct {

}

//2. 该结构体实现HelloServer interface的方法
func (this *Chen)GetAdd(ctx context.Context, In *pb.In)(*pb.Out,error)  {
	return &amp;pb.Out{Size:In.Num+100},nil
}

func main() {
	fmt.Println(&quot;server runing...&quot;)

	//3. 创建网络
	ln, err := net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:12345&quot;)
	if err != nil {
		fmt.Println(&quot;net.Listen error:&quot;, err)
		return
	}
	defer ln.Close()

	//4. 创建gRPC句柄
	srv := grpc.NewServer()

	//5. 注册server
	pb.RegisterHelloServer(srv, &amp;Chen{})

	//6. 等待网络连接
	err = srv.Serve(ln)
	if err != nil {
		fmt.Println(&quot;srv.Serve error:&quot;, err)
		return
	}

}
</code></pre>
<h2 id="客户端代码">客户端代码</h2>
<pre><code class="language-go">package main

import (
	&quot;google.golang.org/grpc&quot;
	&quot;fmt&quot;
	pb &quot;gRPC/myproto&quot;
	&quot;context&quot;
)

func main() {
	//1 连接服务器
	conn, err := grpc.Dial(&quot;127.0.0.1:12345&quot;,grpc.WithInsecure())//grpc.WithInsecure()指定后才不会报错
	if err != nil {
		fmt.Println(&quot;grpc.Dial error:&quot;, err)
		return
	}
	defer conn.Close()

	//2 创建客户端句柄
	cln := pb.NewHelloClient(conn)

	//3 调用服务器函数(RPC)
	out,err := cln.GetAdd(context.Background(), &amp;pb.In{Num:10})
	if err != nil {
		fmt.Println(&quot;grpc.Dial error:&quot;, err)
		return
	}

	//4 打印
	fmt.Println(&quot;得到数据:&quot;, out.Size)
}

</code></pre>
<h2 id="运行测试">运行测试</h2>
<p>先后运行服务器和客户端代码，可在客户端打印输出<code>得到数据: 110</code>，说明已经成功在客户端调用服务端程序。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://meetbetter.github.io/tag/CkXDaoDR0" class="tag">
                    Golang
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://meetbetter.github.io/post/golang-protobuf-learning">
                  <h3 class="post-title">
                    Golang protobuf快速上手
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '7c65ded90d138e1d98b6',
        clientSecret: '82107256fb2d1c871aa25c57faf4a523d8da5a54',
        repo: 'meetbetter.github.io',
        owner: 'meetbetter',
        admin: ['meetbetter'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
